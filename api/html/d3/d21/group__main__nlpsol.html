<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>CasADi: Title</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<link rel="search" href="../../search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="CasADi"/>
<link href="../../customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://casadi.org"><img src="/_img/logo_2017_horizontal.png" alt="CasADi" height="55px"/></a>&#160;<span>public API<sup style="font-size: 30%">(<a href="../../../internal/index.html">switch to internal</a>)</sup></span> - <a href="https://github.com/casadi/casadi/tree/1f5f284959d3c7591033b4ff03947ca7a44b3b11" id="1f5f284959d3c7591033b4ff03947ca7a44b3b11" >revision 3.7.0</a></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Title</div>  </div>
</div><!--header-->
<div class="contents">
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Create an NLP solver Creates a solver for the following parametric nonlinear program (NLP): </p><pre class="fragment">min          F(x, p)
x

subject to
LBX &lt;=   x    &lt;= UBX
LBG &lt;= G(x, p) &lt;= UBG
p  == P

nx: number of decision variables
ng: number of constraints
np: number of parameters</pre><h3><a class="anchor" id="autotoc_md18"></a>
General information</h3>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description</th><th>Used in </th></tr>
<tr>
<td>ad_weight</td><td>OT_DOUBLE</td><td>Weighting factor for derivative calculation.When there is an option of either using forward or reverse mode directional derivatives, the condition ad_weight*nf&lt;=(1-ad_weight)*na is used where nf and na are estimates of the number of forward/reverse mode directional derivatives needed. By default, ad_weight is calculated automatically, but this can be overridden by setting this option. In particular, 0 means forcing forward mode and 1 forcing reverse mode. Leave unset for (class specific) heuristics.</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>ad_weight_sp</td><td>OT_DOUBLE</td><td>Weighting factor for sparsity pattern calculation calculation.Overrides default behavior. Set to 0 and 1 to force forward and reverse mode respectively. Cf. option "ad_weight". When set to -1, sparsity is completely ignored and dense matrices are used.</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>always_inline</td><td>OT_BOOL</td><td>Force inlining.</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>bound_consistency</td><td>OT_BOOL</td><td>Ensure that primal-dual solution is consistent with the bounds</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>cache</td><td>OT_DICT</td><td>Prepopulate the function cache. Default: empty</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>calc_f</td><td>OT_BOOL</td><td>Calculate 'f' in the Nlpsol base class</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>calc_g</td><td>OT_BOOL</td><td>Calculate 'g' in the Nlpsol base class</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>calc_lam_p</td><td>OT_BOOL</td><td>Calculate 'lam_p' in the Nlpsol base class</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>calc_lam_x</td><td>OT_BOOL</td><td>Calculate 'lam_x' in the Nlpsol base class</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>calc_multipliers</td><td>OT_BOOL</td><td>Calculate Lagrange multipliers in the Nlpsol base class</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>common_options</td><td>OT_DICT</td><td>Options for auto-generated functions</td><td>casadi::OracleFunction </td></tr>
<tr>
<td>compiler</td><td>OT_STRING</td><td>Just-in-time compiler plugin to be used.</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>custom_jacobian</td><td>OT_FUNCTION</td><td>Override CasADi's AD. Use together with 'jac_penalty': 0. Note: Highly experimental. Syntax may break often.</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>der_options</td><td>OT_DICT</td><td>Default options to be used to populate forward_options, reverse_options, and jacobian_options before those options are merged in.</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>derivative_of</td><td>OT_FUNCTION</td><td>The function is a derivative of another function. The type of derivative (directional derivative, Jacobian) is inferred from the function name.</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>detect_simple_bounds</td><td>OT_BOOL</td><td>Automatically detect simple bounds (lbx/ubx) (default false). This is hopefully beneficial to speed and robustness but may also have adverse affects: 1) Subtleties in heuristics and stopping criteria may change the solution, 2) IPOPT may lie about multipliers of simple equality bounds unless 'fixed_variable_treatment' is set to 'relax_bounds'.</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>detect_simple_bounds_is_simple</td><td>OT_BOOLVECTOR</td><td>For internal use only.</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>detect_simple_bounds_parts</td><td>OT_FUNCTION</td><td>For internal use only.</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>detect_simple_bounds_target_x</td><td>OT_INTVECTOR</td><td>For internal use only.</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>discrete</td><td>OT_BOOLVECTOR</td><td>Indicates which of the variables are discrete, i.e. integer-valued</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>dump</td><td>OT_BOOL</td><td>Dump function to file upon first evaluation. [false]</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>dump_dir</td><td>OT_STRING</td><td>Directory to dump inputs/outputs to. Make sure the directory exists [.]</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>dump_format</td><td>OT_STRING</td><td>Choose file format to dump matrices. See <a class="el" href="../../da/d45/classcasadi_1_1Matrix.html#ab2064decec05ac73098d1b2b20a1c77e">DM.from_file</a> [mtx]</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>dump_in</td><td>OT_BOOL</td><td>Dump numerical values of inputs to file (readable with <a class="el" href="../../da/d45/classcasadi_1_1Matrix.html#ab2064decec05ac73098d1b2b20a1c77e">DM.from_file</a>) [default: false]</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>dump_out</td><td>OT_BOOL</td><td>Dump numerical values of outputs to file (readable with <a class="el" href="../../da/d45/classcasadi_1_1Matrix.html#ab2064decec05ac73098d1b2b20a1c77e">DM.from_file</a>) [default: false]</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>enable_fd</td><td>OT_BOOL</td><td>Enable derivative calculation by finite differencing. [default: false]]</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>enable_forward</td><td>OT_BOOL</td><td>Enable derivative calculation using generated functions for Jacobian-times-vector products - typically using forward mode AD - if available. [default: true]</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>enable_jacobian</td><td>OT_BOOL</td><td>Enable derivative calculation using generated functions for Jacobians of all differentiable outputs with respect to all differentiable inputs - if available. [default: true]</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>enable_reverse</td><td>OT_BOOL</td><td>Enable derivative calculation using generated functions for transposed Jacobian-times-vector products - typically using reverse mode AD - if available. [default: true]</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>equality</td><td>OT_BOOLVECTOR</td><td>Indicate an upfront hint which of the constraints are equalities. Some solvers may be able to exploit this knowledge. When true, the corresponding lower and upper bounds are assumed equal. When false, the corresponding bounds may be equal or different.</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>error_on_fail</td><td>OT_BOOL</td><td>Throw exceptions when function evaluation fails (default true).</td><td>casadi::ProtoFunction </td></tr>
<tr>
<td>eval_errors_fatal</td><td>OT_BOOL</td><td>When errors occur during evaluation of f,g,...,stop the iterations</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>expand</td><td>OT_BOOL</td><td>Replace <a class="el" href="../../de/d57/classcasadi_1_1MX.html" title="MX - Matrix expression.">MX</a> with SX expressions in problem formulation [false] This happens before creating derivatives unless indicated by postpone_expand</td><td>casadi::OracleFunction </td></tr>
<tr>
<td>external_transform</td><td>OT_VECTORVECTOR</td><td>List of external_transform instruction arguments. Default: empty</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>fd_method</td><td>OT_STRING</td><td>Method for finite differencing [default 'central']</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>fd_options</td><td>OT_DICT</td><td>Options to be passed to the finite difference instance</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>forward_options</td><td>OT_DICT</td><td>Options to be passed to a forward mode constructor</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>gather_stats</td><td>OT_BOOL</td><td>Deprecated option (ignored): Statistics are now always collected.</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>ignore_check_vec</td><td>OT_BOOL</td><td>If set to true, the input shape of F will not be checked.</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>input_scheme</td><td>OT_STRINGVECTOR</td><td>Deprecated option (ignored)</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>inputs_check</td><td>OT_BOOL</td><td>Throw exceptions when the numerical values of the inputs don't make sense</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>is_diff_in</td><td>OT_BOOLVECTOR</td><td>Indicate for each input if it should be differentiable.</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>is_diff_out</td><td>OT_BOOLVECTOR</td><td>Indicate for each output if it should be differentiable.</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>iteration_callback</td><td>OT_FUNCTION</td><td>A function that will be called at each iteration with the solver as input. Check documentation of <a class="el" href="../../d6/dac/classcasadi_1_1Callback.html" title="Callback function functionality.">Callback</a>.</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>iteration_callback_ignore_errors</td><td>OT_BOOL</td><td>If set to true, errors thrown by iteration_callback will be ignored.</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>iteration_callback_step</td><td>OT_INT</td><td>Only call the callback function every few iterations.</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>jac_penalty</td><td>OT_DOUBLE</td><td>When requested for a number of forward/reverse directions, it may be cheaper to compute first the full jacobian and then multiply with seeds, rather than obtain the requested directions in a straightforward manner. Casadi uses a heuristic to decide which is cheaper. A high value of 'jac_penalty' makes it less likely for the heurstic to chose the full Jacobian strategy. The special value -1 indicates never to use the full Jacobian strategy</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>jacobian_options</td><td>OT_DICT</td><td>Options to be passed to a Jacobian constructor</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>jit</td><td>OT_BOOL</td><td>Use just-in-time compiler to speed up the evaluation</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>jit_cleanup</td><td>OT_BOOL</td><td>Cleanup up the temporary source file that jit creates. Default: true</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>jit_name</td><td>OT_STRING</td><td>The file name used to write out code. The actual file names used depend on 'jit_temp_suffix' and include extensions. Default: 'jit_tmp'</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>jit_options</td><td>OT_DICT</td><td>Options to be passed to the jit compiler.</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>jit_serialize</td><td>OT_STRING</td><td>Specify behaviour when serializing a jitted function: SOURCE|link|embed.</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>jit_temp_suffix</td><td>OT_BOOL</td><td>Use a temporary (seemingly random) filename suffix for generated code and libraries. This is desired for thread-safety. This behaviour may defeat caching compiler wrappers. Default: true</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>max_io</td><td>OT_INT</td><td>Acceptable number of inputs and outputs. Warn if exceeded.</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>max_num_dir</td><td>OT_INT</td><td>Specify the maximum number of directions for derivative functions. Overrules the builtin optimized_num_dir.</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>min_lam</td><td>OT_DOUBLE</td><td>Minimum allowed multiplier value</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>monitor</td><td>OT_STRINGVECTOR</td><td>Set of user problem functions to be monitored</td><td>casadi::OracleFunction </td></tr>
<tr>
<td>never_inline</td><td>OT_BOOL</td><td>Forbid inlining.</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>no_nlp_grad</td><td>OT_BOOL</td><td>Prevent the creation of the 'nlp_grad' function</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>oracle_options</td><td>OT_DICT</td><td>Options to be passed to the oracle function</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>output_scheme</td><td>OT_STRINGVECTOR</td><td>Deprecated option (ignored)</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>post_expand</td><td>OT_BOOL</td><td>After construction, expand this <a class="el" href="../../da/da4/classcasadi_1_1Function.html" title="Function object.">Function</a>. Default: False</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>post_expand_options</td><td>OT_DICT</td><td>Options to be passed to post-construction expansion. Default: empty</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>postpone_expand</td><td>OT_BOOL</td><td>When expand is active, postpone it until after creation of derivatives. Default: False</td><td>casadi::OracleFunction </td></tr>
<tr>
<td>print_in</td><td>OT_BOOL</td><td>Print numerical values of inputs [default: false]</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>print_out</td><td>OT_BOOL</td><td>Print numerical values of outputs [default: false]</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>print_time</td><td>OT_BOOL</td><td>print information about execution time. Implies record_time.</td><td>casadi::ProtoFunction </td></tr>
<tr>
<td>record_time</td><td>OT_BOOL</td><td>record information about execution time, for retrieval with stats().</td><td>casadi::ProtoFunction </td></tr>
<tr>
<td>regularity_check</td><td>OT_BOOL</td><td>Throw exceptions when NaN or Inf appears during evaluation</td><td>casadi::ProtoFunction </td></tr>
<tr>
<td>reverse_options</td><td>OT_DICT</td><td>Options to be passed to a reverse mode constructor</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>sens_linsol</td><td>OT_STRING</td><td>Linear solver used for parametric sensitivities (default 'qr').</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>sens_linsol_options</td><td>OT_DICT</td><td>Linear solver options used for parametric sensitivities.</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>show_eval_warnings</td><td>OT_BOOL</td><td>Show warnings generated from function evaluations [true]</td><td>casadi::OracleFunction </td></tr>
<tr>
<td>specific_options</td><td>OT_DICT</td><td>Options for specific auto-generated functions, overwriting the defaults from common_options. Nested dictionary.</td><td>casadi::OracleFunction </td></tr>
<tr>
<td>user_data</td><td>OT_VOIDPTR</td><td>A user-defined field that can be used to identify the function or pass additional information</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>verbose</td><td>OT_BOOL</td><td>Verbose evaluation &ndash; for debugging</td><td>casadi::ProtoFunction </td></tr>
<tr>
<td>verbose_init</td><td>OT_BOOL</td><td>Print out timing information about the different stages of initialization</td><td>casadi::Nlpsol </td></tr>
<tr>
<td>warn_initial_bounds</td><td>OT_BOOL</td><td>Warn if the initial guess does not satisfy LBX and UBX</td><td>casadi::Nlpsol </td></tr>
</table>
</dd></dl>
<p><a class="anchor" id="schemes"></a></p><table class="doxtable">
<caption><a class="el" href="../../d1/d44/classcasadi_1_1Input.html" title="Input instruction.">Input</a> scheme: casadi::NlpsolInput (NLPSOL_NUM_IN = 8)</caption>
<tr>
<th>Full name</th><th>Short</th><th>Description </th></tr>
<tr>
<td>NLPSOL_X0</td><td>x0</td><td>Decision variables, initial guess (nx x 1) </td></tr>
<tr>
<td>NLPSOL_P</td><td>p</td><td>Value of fixed parameters (np x 1) </td></tr>
<tr>
<td>NLPSOL_LBX</td><td>lbx</td><td>Decision variables lower bound (nx x 1), default -inf. </td></tr>
<tr>
<td>NLPSOL_UBX</td><td>ubx</td><td>Decision variables upper bound (nx x 1), default +inf. </td></tr>
<tr>
<td>NLPSOL_LBG</td><td>lbg</td><td>Constraints lower bound (ng x 1), default -inf. </td></tr>
<tr>
<td>NLPSOL_UBG</td><td>ubg</td><td>Constraints upper bound (ng x 1), default +inf. </td></tr>
<tr>
<td>NLPSOL_LAM_X0</td><td>lam_x0</td><td>Lagrange multipliers for bounds on X, initial guess (nx x 1) </td></tr>
<tr>
<td>NLPSOL_LAM_G0</td><td>lam_g0</td><td>Lagrange multipliers for bounds on G, initial guess (ng x 1) </td></tr>
</table>
<p><a class="anchor" id="schemes"></a></p><table class="doxtable">
<caption><a class="el" href="../../df/da2/classcasadi_1_1Output.html" title="Input instruction.">Output</a> scheme: casadi::NlpsolOutput (NLPSOL_NUM_OUT = 6)</caption>
<tr>
<th>Full name</th><th>Short</th><th>Description </th></tr>
<tr>
<td>NLPSOL_X</td><td>x</td><td>Decision variables at the optimal solution (nx x 1) </td></tr>
<tr>
<td>NLPSOL_F</td><td>f</td><td>Cost function value at the optimal solution (1 x 1) </td></tr>
<tr>
<td>NLPSOL_G</td><td>g</td><td>Constraints function at the optimal solution (ng x 1) </td></tr>
<tr>
<td>NLPSOL_LAM_X</td><td>lam_x</td><td>Lagrange multipliers for bounds on X at the solution (nx x 1) </td></tr>
<tr>
<td>NLPSOL_LAM_G</td><td>lam_g</td><td>Lagrange multipliers for bounds on G at the solution (ng x 1) </td></tr>
<tr>
<td>NLPSOL_LAM_P</td><td>lam_p</td><td>Lagrange multipliers for bounds on P at the solution (np x 1) </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md19"></a>
List of plugins</h3>
<p>- <a href='#plugin_Nlpsol_ampl'>ampl</a> </p>
<p>- <a href='#plugin_Nlpsol_blocksqp'>blocksqp</a> </p>
<p>- <a href='#plugin_Nlpsol_bonmin'>bonmin</a> </p>
<p>- <a href='#plugin_Nlpsol_fatrop'>fatrop</a> </p>
<p>- <a href='#plugin_Nlpsol_ipopt'>ipopt</a> </p>
<p>- <a href='#plugin_Nlpsol_knitro'>knitro</a> </p>
<p>- <a href='#plugin_Nlpsol_madnlp'>madnlp</a> </p>
<p>- <a href='#plugin_Nlpsol_snopt'>snopt</a> </p>
<p>- <a href='#plugin_Nlpsol_worhp'>worhp</a> </p>
<p>- <a href='#plugin_Nlpsol_feasiblesqpmethod'>feasiblesqpmethod</a> </p>
<p>- <a href='#plugin_Nlpsol_qrsqp'>qrsqp</a> </p>
<p>- <a href='#plugin_Nlpsol_scpgen'>scpgen</a> </p>
<p>- <a href='#plugin_Nlpsol_sqpmethod'>sqpmethod</a> </p>
<p>Note: some of the plugins in this list might not be available on your system.  Also, there might be extra plugins available to you that are not listed here. You can obtain their documentation with <code>Nlpsol.doc("myextraplugin")</code></p>
<hr  />
  <h4>ampl <a class="anchor" id="plugin_Nlpsol_ampl"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Interface to AMPL</p>
<dl class="section author"><dt>Author</dt><dd>Joel Andersson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017</dd></dl>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_22b">https://github.com/casadi/casadi/wiki/L_22b</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>solver</td><td>OT_STRING</td><td>AMPL solver binary </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>blocksqp <a class="anchor" id="plugin_Nlpsol_blocksqp"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>This is a modified version of blockSQP by Janka et al.</p>
<dl class="section author"><dt>Author</dt><dd>Dennis Janka, Joel Andersson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2012-2015, 2016</dd></dl>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_224">https://github.com/casadi/casadi/wiki/L_224</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>block_hess</td><td>OT_INT</td><td>Blockwise Hessian approximation? </td></tr>
<tr>
<td>col_eps</td><td>OT_DOUBLE</td><td>Epsilon for COL scaling strategy </td></tr>
<tr>
<td>col_tau1</td><td>OT_DOUBLE</td><td>tau1 for COL scaling strategy </td></tr>
<tr>
<td>col_tau2</td><td>OT_DOUBLE</td><td>tau2 for COL scaling strategy </td></tr>
<tr>
<td>conv_strategy</td><td>OT_INT</td><td>Convexification strategy </td></tr>
<tr>
<td>delta</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>delta_h0</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>eps</td><td>OT_DOUBLE</td><td>Values smaller than this are regarded as numerically zero </td></tr>
<tr>
<td>eta</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>fallback_scaling</td><td>OT_INT</td><td>If indefinite update is used, the type of fallback strategy </td></tr>
<tr>
<td>fallback_update</td><td>OT_INT</td><td>If indefinite update is used, the type of fallback strategy </td></tr>
<tr>
<td>gamma_f</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>gamma_theta</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>globalization</td><td>OT_BOOL</td><td>Enable globalization </td></tr>
<tr>
<td>hess_damp</td><td>OT_INT</td><td>Activate Powell damping for BFGS </td></tr>
<tr>
<td>hess_damp_fac</td><td>OT_DOUBLE</td><td>Damping factor for BFGS Powell modification </td></tr>
<tr>
<td>hess_lim_mem</td><td>OT_INT</td><td>Full or limited memory </td></tr>
<tr>
<td>hess_memsize</td><td>OT_INT</td><td>Memory size for L-BFGS updates </td></tr>
<tr>
<td>hess_scaling</td><td>OT_INT</td><td>Scaling strategy for Hessian approximation </td></tr>
<tr>
<td>hess_update</td><td>OT_INT</td><td>Type of Hessian approximation </td></tr>
<tr>
<td>ini_hess_diag</td><td>OT_DOUBLE</td><td>Initial Hessian guess: diagonal matrix diag(iniHessDiag) </td></tr>
<tr>
<td>kappa_f</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>kappa_minus</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>kappa_plus</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>kappa_plus_max</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>kappa_soc</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>linsol</td><td>OT_STRING</td><td>The linear solver to be used by the QP method </td></tr>
<tr>
<td>max_consec_reduced_steps</td><td>OT_INT</td><td>Maximum number of consecutive reduced steps </td></tr>
<tr>
<td>max_consec_skipped_updates</td><td>OT_INT</td><td>Maximum number of consecutive skipped updates </td></tr>
<tr>
<td>max_conv_qp</td><td>OT_INT</td><td>How many additional QPs may be solved for convexification per iteration? </td></tr>
<tr>
<td>max_it_qp</td><td>OT_INT</td><td>Maximum number of QP iterations per SQP iteration </td></tr>
<tr>
<td>max_iter</td><td>OT_INT</td><td>Maximum number of SQP iterations </td></tr>
<tr>
<td>max_line_search</td><td>OT_INT</td><td>Maximum number of steps in line search </td></tr>
<tr>
<td>max_soc_iter</td><td>OT_INT</td><td>Maximum number of SOC line search iterations </td></tr>
<tr>
<td>max_time_qp</td><td>OT_DOUBLE</td><td>Maximum number of time in seconds per QP solve per SQP iteration </td></tr>
<tr>
<td>nlinfeastol</td><td>OT_DOUBLE</td><td>Nonlinear feasibility tolerance </td></tr>
<tr>
<td>obj_lo</td><td>OT_DOUBLE</td><td>Lower bound on objective function [-inf] </td></tr>
<tr>
<td>obj_up</td><td>OT_DOUBLE</td><td>Upper bound on objective function [inf] </td></tr>
<tr>
<td>opttol</td><td>OT_DOUBLE</td><td>Optimality tolerance </td></tr>
<tr>
<td>print_header</td><td>OT_BOOL</td><td>Print solver header at startup </td></tr>
<tr>
<td>print_iteration</td><td>OT_BOOL</td><td>Print SQP iterations </td></tr>
<tr>
<td>print_maxit_reached</td><td>OT_BOOL</td><td>Print error when maximum number of SQP iterations reached </td></tr>
<tr>
<td>qp_init</td><td>OT_BOOL</td><td>Use warmstarting </td></tr>
<tr>
<td>qpsol</td><td>OT_STRING</td><td>The QP solver to be used by the SQP method </td></tr>
<tr>
<td>qpsol_options</td><td>OT_DICT</td><td>Options to be passed to the QP solver </td></tr>
<tr>
<td>restore_feas</td><td>OT_BOOL</td><td>Use feasibility restoration phase </td></tr>
<tr>
<td>rho</td><td>OT_DOUBLE</td><td>Feasibility restoration phase parameter </td></tr>
<tr>
<td>s_f</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>s_theta</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>schur</td><td>OT_BOOL</td><td>Use qpOASES Schur compliment approach </td></tr>
<tr>
<td>skip_first_globalization</td><td>OT_BOOL</td><td>No globalization strategy in first iteration </td></tr>
<tr>
<td>theta_max</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>theta_min</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>warmstart</td><td>OT_BOOL</td><td>Use warmstarting </td></tr>
<tr>
<td>which_second_derv</td><td>OT_INT</td><td>For which block should second derivatives be provided by the user </td></tr>
<tr>
<td>zeta</td><td>OT_DOUBLE</td><td>Feasibility restoration phase parameter </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>bonmin <a class="anchor" id="plugin_Nlpsol_bonmin"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>When in warmstart mode, output NLPSOL_LAM_X may be used as input</p>
<p>NOTE: Even when max_iter == 0, it is not guaranteed that input(NLPSOL_X0) == output(NLPSOL_X). Indeed if bounds on X or constraints are unmet, they will differ.</p>
<p>For a good tutorial on BONMIN, see <a href="http://drops.dagstuhl.de/volltexte/2009/2089/pdf/09061.WaechterAndreas.Paper.2089.pdf">http://drops.dagstuhl.de/volltexte/2009/2089/pdf/09061.WaechterAndreas.Paper.2089.pdf</a></p>
<p>A good resource about the algorithms in BONMIN is: Wachter and L. T. Biegler, On the Implementation of an Interior-Point Filter Line-Search Algorithm for Large-Scale Nonlinear Programming, Mathematical Programming 106(1), pp. 25-57, 2006 (As Research Report RC 23149, IBM T. J. Watson Research Center, Yorktown, USA</p>
<p>Caveats:</p><ul>
<li><p class="startli">with default options, multipliers for the decision variables are wrong for equality constraints. Change the 'fixed_variable_treatment' to 'make_constraint' or 'relax_bounds' to obtain correct results.</p>
<p class="startli">Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_223">https://github.com/casadi/casadi/wiki/L_223</a></p>
</li>
</ul>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>bonmin</td><td>OT_DICT</td><td>Options to be passed to BONMIN </td></tr>
<tr>
<td>con_integer_md</td><td>OT_DICT</td><td>Integer metadata (a dictionary with lists of integers) about constraints to be passed to BONMIN </td></tr>
<tr>
<td>con_numeric_md</td><td>OT_DICT</td><td>Numeric metadata (a dictionary with lists of reals) about constraints to be passed to BONMIN </td></tr>
<tr>
<td>con_string_md</td><td>OT_DICT</td><td>String metadata (a dictionary with lists of strings) about constraints to be passed to BONMIN </td></tr>
<tr>
<td>grad_f</td><td>OT_FUNCTION</td><td><a class="el" href="../../da/da4/classcasadi_1_1Function.html" title="Function object.">Function</a> for calculating the gradient of the objective (column, autogenerated by default) </td></tr>
<tr>
<td>grad_f_options</td><td>OT_DICT</td><td>Options for the autogenerated gradient of the objective. </td></tr>
<tr>
<td>hess_lag</td><td>OT_FUNCTION</td><td><a class="el" href="../../da/da4/classcasadi_1_1Function.html" title="Function object.">Function</a> for calculating the Hessian of the Lagrangian (autogenerated by default) </td></tr>
<tr>
<td>hess_lag_options</td><td>OT_DICT</td><td>Options for the autogenerated Hessian of the Lagrangian. </td></tr>
<tr>
<td>jac_g</td><td>OT_FUNCTION</td><td><a class="el" href="../../da/da4/classcasadi_1_1Function.html" title="Function object.">Function</a> for calculating the Jacobian of the constraints (autogenerated by default) </td></tr>
<tr>
<td>jac_g_options</td><td>OT_DICT</td><td>Options for the autogenerated Jacobian of the constraints. </td></tr>
<tr>
<td>pass_nonlinear_constraints</td><td>OT_BOOL</td><td>Pass list of constraints entering nonlinearly to BONMIN </td></tr>
<tr>
<td>pass_nonlinear_variables</td><td>OT_BOOL</td><td>Pass list of variables entering nonlinearly to BONMIN </td></tr>
<tr>
<td>sos1_groups</td><td>OT_INTVECTORVECTOR</td><td>Options for the autogenerated gradient of the objective. </td></tr>
<tr>
<td>sos1_priorities</td><td>OT_INTVECTOR</td><td>Options for the autogenerated gradient of the objective. </td></tr>
<tr>
<td>sos1_weights</td><td>OT_DOUBLEVECTORVECTOR</td><td>Options for the autogenerated gradient of the objective. </td></tr>
<tr>
<td>var_integer_md</td><td>OT_DICT</td><td>Integer metadata (a dictionary with lists of integers) about variables to be passed to BONMIN </td></tr>
<tr>
<td>var_numeric_md</td><td>OT_DICT</td><td>Numeric metadata (a dictionary with lists of reals) about variables to be passed to BONMIN </td></tr>
<tr>
<td>var_string_md</td><td>OT_DICT</td><td>String metadata (a dictionary with lists of strings) about variables to be passed to BONMIN </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>fatrop <a class="anchor" id="plugin_Nlpsol_fatrop"></a> </h4>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>N</td><td>OT_INT</td><td>OCP horizon </td></tr>
<tr>
<td>convexify_margin</td><td>OT_DOUBLE</td><td>When using a convexification strategy, make sure that the smallest eigenvalue is at least this (default: 1e-7). </td></tr>
<tr>
<td>convexify_strategy</td><td>OT_STRING</td><td>NONE|regularize|eigen-reflect|eigen-clip. Strategy to convexify the Lagrange Hessian before passing it to the solver. </td></tr>
<tr>
<td>debug</td><td>OT_BOOL</td><td>Produce debug information (default: false) </td></tr>
<tr>
<td>fatrop</td><td>OT_DICT</td><td>Options to be passed to fatrop </td></tr>
<tr>
<td>ng</td><td>OT_INTVECTOR</td><td>Number of non-dynamic constraints, length N+1 </td></tr>
<tr>
<td>nu</td><td>OT_INTVECTOR</td><td>Number of controls, length N+1 </td></tr>
<tr>
<td>nx</td><td>OT_INTVECTOR</td><td>Number of states, length N+1 </td></tr>
<tr>
<td>structure_detection</td><td>OT_STRING</td><td>NONE | auto | manual </td></tr>
</table>
</dd></dl>
<p>Fatrop is a solver developed at KU Leuven by Lander Vanroye and Wilm Decre. The algorithm is based on IPOPT, but the linear algebra is much more efficient.</p>
<p>With structure_detection = 'none' (default), it will behave as a general-purpose dense nonlinear program solver.</p>
<p>With structure_detection = 'manual', you can specify a block structure.</p>
<p>Let's say you perform multiply shooting with a system</p>
<p>x_k+1 = A_k x_k + B_k u_k</p>
<p>Suppose your constraint Jacobian looks like: </p><pre class="fragment"> nx0  nu0  nx1  nu1  nx2  nu2
 -----------------------------
</pre><p> nx1 |A0 B0 I0 <br  />
 ng1 |C0 D0 <br  />
 nx2 | A1 B1 I1 <br  />
 ng2 | C1 D1 <br  />
 ng3 | C2 D2</p>
<p>with n* capturing the number of states, inputs, and constraints in each block.</p>
<p>You can then specify this structure with:</p>
<p>N = 2 nx = [nx0 ,nx1, nx2] nu = [nu0, nu1, nu2] ng = [ng1, ng2, ng3]</p>
<p>With structure_detection = 'auto', the block-defining parameters nx, nu, ng, and N are automatically detected from the sparsity pattern.</p>
<hr  />
  <h4>ipopt <a class="anchor" id="plugin_Nlpsol_ipopt"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>When in warmstart mode, output NLPSOL_LAM_X may be used as input</p>
<p>NOTE: Even when max_iter == 0, it is not guaranteed that input(NLPSOL_X0) == output(NLPSOL_X). Indeed if bounds on X or constraints are unmet, they will differ.</p>
<p>For a good tutorial on IPOPT, see <a href="http://drops.dagstuhl.de/volltexte/2009/2089/pdf/09061.WaechterAndreas.Paper.2089.pdf">http://drops.dagstuhl.de/volltexte/2009/2089/pdf/09061.WaechterAndreas.Paper.2089.pdf</a></p>
<p>A good resource about the algorithms in IPOPT is: Wachter and L. T. Biegler, On the Implementation of an Interior-Point Filter Line-Search Algorithm for Large-Scale Nonlinear Programming, Mathematical Programming 106(1), pp. 25-57, 2006 (As Research Report RC 23149, IBM T. J. Watson Research Center, Yorktown, USA</p>
<p>Caveats:</p><ul>
<li><p class="startli">with default options, multipliers for the decision variables are wrong for equality constraints. Change the 'fixed_variable_treatment' to 'make_constraint' or 'relax_bounds' to obtain correct results.</p>
<p class="startli">Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_21y">https://github.com/casadi/casadi/wiki/L_21y</a></p>
</li>
</ul>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>clip_inactive_lam</td><td>OT_BOOL</td><td>Explicitly set Lagrange multipliers to 0 when bound is deemed inactive (default: false). </td></tr>
<tr>
<td>con_integer_md</td><td>OT_DICT</td><td>Integer metadata (a dictionary with lists of integers) about constraints to be passed to IPOPT </td></tr>
<tr>
<td>con_numeric_md</td><td>OT_DICT</td><td>Numeric metadata (a dictionary with lists of reals) about constraints to be passed to IPOPT </td></tr>
<tr>
<td>con_string_md</td><td>OT_DICT</td><td>String metadata (a dictionary with lists of strings) about constraints to be passed to IPOPT </td></tr>
<tr>
<td>convexify_margin</td><td>OT_DOUBLE</td><td>When using a convexification strategy, make sure that the smallest eigenvalue is at least this (default: 1e-7). </td></tr>
<tr>
<td>convexify_strategy</td><td>OT_STRING</td><td>NONE|regularize|eigen-reflect|eigen-clip. Strategy to convexify the Lagrange Hessian before passing it to the solver. </td></tr>
<tr>
<td>grad_f</td><td>OT_FUNCTION</td><td><a class="el" href="../../da/da4/classcasadi_1_1Function.html" title="Function object.">Function</a> for calculating the gradient of the objective (column, autogenerated by default) </td></tr>
<tr>
<td>hess_lag</td><td>OT_FUNCTION</td><td><a class="el" href="../../da/da4/classcasadi_1_1Function.html" title="Function object.">Function</a> for calculating the Hessian of the Lagrangian (autogenerated by default) </td></tr>
<tr>
<td>inactive_lam_strategy</td><td>OT_STRING</td><td>Strategy to detect if a bound is inactive. RELTOL: use solver-defined constraint tolerance * inactive_lam_value|abstol: use inactive_lam_value </td></tr>
<tr>
<td>inactive_lam_value</td><td>OT_DOUBLE</td><td>Value used in inactive_lam_strategy (default: 10). </td></tr>
<tr>
<td>ipopt</td><td>OT_DICT</td><td>Options to be passed to IPOPT </td></tr>
<tr>
<td>jac_g</td><td>OT_FUNCTION</td><td><a class="el" href="../../da/da4/classcasadi_1_1Function.html" title="Function object.">Function</a> for calculating the Jacobian of the constraints (autogenerated by default) </td></tr>
<tr>
<td>max_iter_eig</td><td>OT_DOUBLE</td><td>Maximum number of iterations to compute an eigenvalue decomposition (default: 50). </td></tr>
<tr>
<td>pass_nonlinear_variables</td><td>OT_BOOL</td><td>Pass list of variables entering nonlinearly to IPOPT </td></tr>
<tr>
<td>var_integer_md</td><td>OT_DICT</td><td>Integer metadata (a dictionary with lists of integers) about variables to be passed to IPOPT </td></tr>
<tr>
<td>var_numeric_md</td><td>OT_DICT</td><td>Numeric metadata (a dictionary with lists of reals) about variables to be passed to IPOPT </td></tr>
<tr>
<td>var_string_md</td><td>OT_DICT</td><td>String metadata (a dictionary with lists of strings) about variables to be passed to IPOPT </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>knitro <a class="anchor" id="plugin_Nlpsol_knitro"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>KNITRO interface</p>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_22c">https://github.com/casadi/casadi/wiki/L_22c</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>complem_variables</td><td>OT_INTVECTORVECTOR</td><td>List of complementary constraints on simple bounds. Pair (i, j) encodes complementarity between the bounds on variable i and variable j. </td></tr>
<tr>
<td>contype</td><td>OT_INTVECTOR</td><td>Type of constraint </td></tr>
<tr>
<td>detect_linear_constraints</td><td>OT_BOOL</td><td>Detect type of constraints </td></tr>
<tr>
<td>knitro</td><td>OT_DICT</td><td>Options to be passed to KNITRO </td></tr>
<tr>
<td>options_file</td><td>OT_STRING</td><td>Read options from file (solver specific) </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>madnlp <a class="anchor" id="plugin_Nlpsol_madnlp"></a> </h4>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>convexify_margin</td><td>OT_DOUBLE</td><td>When using a convexification strategy, make sure that the smallest eigenvalue is at least this (default: 1e-7). </td></tr>
<tr>
<td>convexify_strategy</td><td>OT_STRING</td><td>NONE|regularize|eigen-reflect|eigen-clip. Strategy to convexify the Lagrange Hessian before passing it to the solver. </td></tr>
<tr>
<td>madnlp</td><td>OT_DICT</td><td>Options to be passed to madnlp </td></tr>
<tr>
<td>ng</td><td>OT_INTVECTOR</td><td>Number of constraints </td></tr>
<tr>
<td>nw</td><td>OT_INTVECTOR</td><td>Number of variables </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>snopt <a class="anchor" id="plugin_Nlpsol_snopt"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>SNOPT interface</p>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_22m">https://github.com/casadi/casadi/wiki/L_22m</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>snopt</td><td>OT_DICT</td><td>Options to be passed to SNOPT </td></tr>
<tr>
<td>start</td><td>OT_STRING</td><td>Warm-start options for Worhp: cold|warm|hot </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>worhp <a class="anchor" id="plugin_Nlpsol_worhp"></a> </h4>
<p>WORHP interface</p>
<p>Designed for Worhp 1.12</p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>worhp</td><td>OT_DICT</td><td>Options to be passed to WORHP </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>feasiblesqpmethod <a class="anchor" id="plugin_Nlpsol_feasiblesqpmethod"></a> </h4>
<dl class="section user"><dt></dt><dd>A textbook FeasibleSQPMethod</dd></dl>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_241">https://github.com/casadi/casadi/wiki/L_241</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>anderson_memory</td><td>OT_INT</td><td>Anderson memory. If Anderson is used default is 1, else default is 0. </td></tr>
<tr>
<td>contraction_acceptance_value</td><td>OT_DOUBLE</td><td>If the empirical contraction rate in the feasibility iterations is above this value in the heuristics the iterations are aborted. </td></tr>
<tr>
<td>convexify_margin</td><td>OT_DOUBLE</td><td>When using a convexification strategy, make sure that the smallest eigenvalue4 is at least this (default: 1e-7). </td></tr>
<tr>
<td>convexify_strategy</td><td>OT_STRING</td><td>NONE|regularize|eigen-reflect|eigen-clip. Strategy to convexify the Lagrange Hessian before passing it to the solver. </td></tr>
<tr>
<td>f</td><td>OT_FUNCTION</td><td><a class="el" href="../../da/da4/classcasadi_1_1Function.html" title="Function object.">Function</a> for calculating the objective function (autogenerated by default) </td></tr>
<tr>
<td>feas_tol</td><td>OT_DOUBLE</td><td>Feasibility tolerance. Below this tolerance an iterate is considered to be feasible. </td></tr>
<tr>
<td>g</td><td>OT_FUNCTION</td><td><a class="el" href="../../da/da4/classcasadi_1_1Function.html" title="Function object.">Function</a> for calculating the constraints (autogenerated by default) </td></tr>
<tr>
<td>grad_f</td><td>OT_FUNCTION</td><td><a class="el" href="../../da/da4/classcasadi_1_1Function.html" title="Function object.">Function</a> for calculating the gradient of the objective (autogenerated by default) </td></tr>
<tr>
<td>hess_lag</td><td>OT_FUNCTION</td><td><a class="el" href="../../da/da4/classcasadi_1_1Function.html" title="Function object.">Function</a> for calculating the Hessian of the Lagrangian (autogenerated by default) </td></tr>
<tr>
<td>hessian_approximation</td><td>OT_STRING</td><td>limited-memory|exact </td></tr>
<tr>
<td>init_feasible</td><td>OT_BOOL</td><td>Initialize the QP subproblems with a feasible initial value (default: false). </td></tr>
<tr>
<td>jac_g</td><td>OT_FUNCTION</td><td><a class="el" href="../../da/da4/classcasadi_1_1Function.html" title="Function object.">Function</a> for calculating the Jacobian of the constraints (autogenerated by default) </td></tr>
<tr>
<td>lbfgs_memory</td><td>OT_INT</td><td>Size of L-BFGS memory. </td></tr>
<tr>
<td>max_inner_iter</td><td>OT_DOUBLE</td><td>Maximum number of inner iterations. </td></tr>
<tr>
<td>max_iter</td><td>OT_INT</td><td>Maximum number of SQP iterations </td></tr>
<tr>
<td>max_iter_eig</td><td>OT_DOUBLE</td><td>Maximum number of iterations to compute an eigenvalue decomposition (default: 50). </td></tr>
<tr>
<td>merit_memory</td><td>OT_INT</td><td>Size of memory to store history of merit function values </td></tr>
<tr>
<td>min_iter</td><td>OT_INT</td><td>Minimum number of SQP iterations </td></tr>
<tr>
<td>optim_tol</td><td>OT_DOUBLE</td><td>Optimality tolerance. Below this value an iterate is considered to be optimal. </td></tr>
<tr>
<td>print_header</td><td>OT_BOOL</td><td>Print the header with problem statistics </td></tr>
<tr>
<td>print_iteration</td><td>OT_BOOL</td><td>Print the iterations </td></tr>
<tr>
<td>print_status</td><td>OT_BOOL</td><td>Print a status message after solving </td></tr>
<tr>
<td>qpsol</td><td>OT_STRING</td><td>The QP solver to be used by the SQP method [qpoases] </td></tr>
<tr>
<td>qpsol_options</td><td>OT_DICT</td><td>Options to be passed to the QP solver </td></tr>
<tr>
<td>solve_type</td><td>OT_STRING</td><td>The solver type: Either SQP or SLP. Defaults to SQP </td></tr>
<tr>
<td>tol_du</td><td>OT_DOUBLE</td><td>Stopping criterion for dual infeasability </td></tr>
<tr>
<td>tol_pr</td><td>OT_DOUBLE</td><td>Stopping criterion for primal infeasibility </td></tr>
<tr>
<td>tr_acceptance</td><td>OT_DOUBLE</td><td>Is the trust-region ratio above this value, the step is accepted. </td></tr>
<tr>
<td>tr_alpha1</td><td>OT_DOUBLE</td><td>Lower alpha in trust-region size criterion. </td></tr>
<tr>
<td>tr_alpha2</td><td>OT_DOUBLE</td><td>Upper alpha in trust-region size criterion. </td></tr>
<tr>
<td>tr_eta1</td><td>OT_DOUBLE</td><td>Lower eta in trust-region acceptance criterion. </td></tr>
<tr>
<td>tr_eta2</td><td>OT_DOUBLE</td><td>Upper eta in trust-region acceptance criterion. </td></tr>
<tr>
<td>tr_rad0</td><td>OT_DOUBLE</td><td>Initial trust-region radius. </td></tr>
<tr>
<td>tr_rad_max</td><td>OT_DOUBLE</td><td>Maximum trust-region radius. </td></tr>
<tr>
<td>tr_rad_min</td><td>OT_DOUBLE</td><td>Minimum trust-region radius. </td></tr>
<tr>
<td>tr_scale_vector</td><td>OT_DOUBLEVECTOR</td><td>Vector that tells where trust-region is applied. </td></tr>
<tr>
<td>tr_tol</td><td>OT_DOUBLE</td><td>Trust-region tolerance. Below this value another scalar is equal to the trust region radius. </td></tr>
<tr>
<td>use_anderson</td><td>OT_BOOL</td><td>Use Anderson Acceleration. (default false) </td></tr>
<tr>
<td>watchdog</td><td>OT_INT</td><td>Number of watchdog iterations in feasibility iterations. After this amount of iterations, it is checked with the contraction acceptance value, if iterations are converging. </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>qrsqp <a class="anchor" id="plugin_Nlpsol_qrsqp"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>A textbook SQPMethod</p>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_22u">https://github.com/casadi/casadi/wiki/L_22u</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>beta</td><td>OT_DOUBLE</td><td>Line-search parameter, restoration factor of stepsize </td></tr>
<tr>
<td>c1</td><td>OT_DOUBLE</td><td>Armijo condition, coefficient of decrease in merit </td></tr>
<tr>
<td>hessian_approximation</td><td>OT_STRING</td><td>limited-memory|exact </td></tr>
<tr>
<td>lbfgs_memory</td><td>OT_INT</td><td>Size of L-BFGS memory. </td></tr>
<tr>
<td>max_iter</td><td>OT_INT</td><td>Maximum number of SQP iterations </td></tr>
<tr>
<td>max_iter_ls</td><td>OT_INT</td><td>Maximum number of linesearch iterations </td></tr>
<tr>
<td>merit_memory</td><td>OT_INT</td><td>Size of memory to store history of merit function values </td></tr>
<tr>
<td>min_iter</td><td>OT_INT</td><td>Minimum number of SQP iterations </td></tr>
<tr>
<td>min_step_size</td><td>OT_DOUBLE</td><td>The size (inf-norm) of the step size should not become smaller than this. </td></tr>
<tr>
<td>print_header</td><td>OT_BOOL</td><td>Print the header with problem statistics </td></tr>
<tr>
<td>print_iteration</td><td>OT_BOOL</td><td>Print the iterations </td></tr>
<tr>
<td>qpsol</td><td>OT_STRING</td><td>The QP solver to be used by the SQP method [qrqp] </td></tr>
<tr>
<td>qpsol_options</td><td>OT_DICT</td><td>Options to be passed to the QP solver </td></tr>
<tr>
<td>regularize</td><td>OT_BOOL</td><td>Automatic regularization of Lagrange Hessian. </td></tr>
<tr>
<td>tol_du</td><td>OT_DOUBLE</td><td>Stopping criterion for dual infeasability </td></tr>
<tr>
<td>tol_pr</td><td>OT_DOUBLE</td><td>Stopping criterion for primal infeasibility </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>scpgen <a class="anchor" id="plugin_Nlpsol_scpgen"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>A structure-exploiting sequential quadratic programming (to be come sequential convex programming) method for nonlinear programming.</p>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_232">https://github.com/casadi/casadi/wiki/L_232</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>beta</td><td>OT_DOUBLE</td><td>Line-search parameter, restoration factor of stepsize </td></tr>
<tr>
<td>c1</td><td>OT_DOUBLE</td><td>Armijo condition, coefficient of decrease in merit </td></tr>
<tr>
<td>codegen</td><td>OT_BOOL</td><td>C-code generation </td></tr>
<tr>
<td>hessian_approximation</td><td>OT_STRING</td><td>gauss-newton|exact </td></tr>
<tr>
<td>lbfgs_memory</td><td>OT_INT</td><td>Size of L-BFGS memory. </td></tr>
<tr>
<td>max_iter</td><td>OT_INT</td><td>Maximum number of SQP iterations </td></tr>
<tr>
<td>max_iter_ls</td><td>OT_INT</td><td>Maximum number of linesearch iterations </td></tr>
<tr>
<td>merit_memsize</td><td>OT_INT</td><td>Size of memory to store history of merit function values </td></tr>
<tr>
<td>merit_start</td><td>OT_DOUBLE</td><td>Lower bound for the merit function parameter </td></tr>
<tr>
<td>name_x</td><td>OT_STRINGVECTOR</td><td>Names of the variables. </td></tr>
<tr>
<td>print_header</td><td>OT_BOOL</td><td>Print the header with problem statistics </td></tr>
<tr>
<td>print_x</td><td>OT_INTVECTOR</td><td>Which variables to print. </td></tr>
<tr>
<td>qpsol</td><td>OT_STRING</td><td>The QP solver to be used by the SQP method </td></tr>
<tr>
<td>qpsol_options</td><td>OT_DICT</td><td>Options to be passed to the QP solver </td></tr>
<tr>
<td>reg_threshold</td><td>OT_DOUBLE</td><td>Threshold for the regularization. </td></tr>
<tr>
<td>regularize</td><td>OT_BOOL</td><td>Automatic regularization of Lagrange Hessian. </td></tr>
<tr>
<td>tol_du</td><td>OT_DOUBLE</td><td>Stopping criterion for dual infeasability </td></tr>
<tr>
<td>tol_pr</td><td>OT_DOUBLE</td><td>Stopping criterion for primal infeasibility </td></tr>
<tr>
<td>tol_pr_step</td><td>OT_DOUBLE</td><td>Stopping criterion for the step size </td></tr>
<tr>
<td>tol_reg</td><td>OT_DOUBLE</td><td>Stopping criterion for regularization </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>sqpmethod <a class="anchor" id="plugin_Nlpsol_sqpmethod"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>A textbook SQPMethod</p>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_22x">https://github.com/casadi/casadi/wiki/L_22x</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>beta</td><td>OT_DOUBLE</td><td>Line-search parameter, restoration factor of stepsize </td></tr>
<tr>
<td>c1</td><td>OT_DOUBLE</td><td>Armijo condition, coefficient of decrease in merit </td></tr>
<tr>
<td>convexify_margin</td><td>OT_DOUBLE</td><td>When using a convexification strategy, make sure that the smallest eigenvalue is at least this (default: 1e-7). </td></tr>
<tr>
<td>convexify_strategy</td><td>OT_STRING</td><td>NONE|regularize|eigen-reflect|eigen-clip. Strategy to convexify the Lagrange Hessian before passing it to the solver. </td></tr>
<tr>
<td>elastic_mode</td><td>OT_BOOL</td><td>Enable the elastic mode which is used when the QP is infeasible (default: false). </td></tr>
<tr>
<td>gamma_0</td><td>OT_DOUBLE</td><td>Starting value for the penalty parameter of elastic mode (default: 1). </td></tr>
<tr>
<td>gamma_1_min</td><td>OT_DOUBLE</td><td>Minimum value for gamma_1 (default: 1e-5). </td></tr>
<tr>
<td>gamma_max</td><td>OT_DOUBLE</td><td>Maximum value for the penalty parameter of elastic mode (default: 1e20). </td></tr>
<tr>
<td>hess_lag</td><td>OT_FUNCTION</td><td><a class="el" href="../../da/da4/classcasadi_1_1Function.html" title="Function object.">Function</a> for calculating the Hessian of the Lagrangian (autogenerated by default) </td></tr>
<tr>
<td>hessian_approximation</td><td>OT_STRING</td><td>limited-memory|exact </td></tr>
<tr>
<td>init_feasible</td><td>OT_BOOL</td><td>Initialize the QP subproblems with a feasible initial value (default: false). </td></tr>
<tr>
<td>jac_fg</td><td>OT_FUNCTION</td><td><a class="el" href="../../da/da4/classcasadi_1_1Function.html" title="Function object.">Function</a> for calculating the gradient of the objective and Jacobian of the constraints (autogenerated by default) </td></tr>
<tr>
<td>lbfgs_memory</td><td>OT_INT</td><td>Size of L-BFGS memory. </td></tr>
<tr>
<td>max_iter</td><td>OT_INT</td><td>Maximum number of SQP iterations </td></tr>
<tr>
<td>max_iter_eig</td><td>OT_DOUBLE</td><td>Maximum number of iterations to compute an eigenvalue decomposition (default: 50). </td></tr>
<tr>
<td>max_iter_ls</td><td>OT_INT</td><td>Maximum number of linesearch iterations </td></tr>
<tr>
<td>merit_memory</td><td>OT_INT</td><td>Size of memory to store history of merit function values </td></tr>
<tr>
<td>min_iter</td><td>OT_INT</td><td>Minimum number of SQP iterations </td></tr>
<tr>
<td>min_step_size</td><td>OT_DOUBLE</td><td>The size (inf-norm) of the step size should not become smaller than this. </td></tr>
<tr>
<td>print_header</td><td>OT_BOOL</td><td>Print the header with problem statistics </td></tr>
<tr>
<td>print_iteration</td><td>OT_BOOL</td><td>Print the iterations </td></tr>
<tr>
<td>print_status</td><td>OT_BOOL</td><td>Print a status message after solving </td></tr>
<tr>
<td>qpsol</td><td>OT_STRING</td><td>The QP solver to be used by the SQP method [qpoases] </td></tr>
<tr>
<td>qpsol_options</td><td>OT_DICT</td><td>Options to be passed to the QP solver </td></tr>
<tr>
<td>second_order_corrections</td><td>OT_BOOL</td><td>Enable second order corrections. These are used when a step is considered bad by the merit function and constraint norm (default: false). </td></tr>
<tr>
<td>tol_du</td><td>OT_DOUBLE</td><td>Stopping criterion for dual infeasability </td></tr>
<tr>
<td>tol_pr</td><td>OT_DOUBLE</td><td>Stopping criterion for primal infeasibility </td></tr>
</table>
</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Joel Andersson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2011-2015</dd></dl>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_21q">https://github.com/casadi/casadi/wiki/L_21q</a> </p>
</div><!-- contents -->
</body>
</html>
