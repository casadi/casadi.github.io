<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>CasADi: Symbolic core</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<link rel="search" href="../../search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="CasADi"/>
<link href="../../customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://casadi.org"><img src="/_img/logo_2017_horizontal.png" alt="CasADi" height="55px"/></a>&#160;<span>public API<sup style="font-size: 30%">(<a href="../../../internal/index.html">switch to internal</a>)</sup></span> - <a href="https://github.com/casadi/casadi/tree/279e0b80886dc5eb43a9d12a1056c550dc3b786e" id="279e0b80886dc5eb43a9d12a1056c550dc3b786e" >revision 3.6.6</a></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Symbolic core </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><table style="width: 100%;">
<tr>
<td style="text-align: left;">Previous chapter: <a class="el" href="../../d3/def/chapter2.html">Installation</a> </td><td style="text-align: right;">Next chapter: <a class="el" href="../../dc/d18/chapter4.html">Integrators</a>  </td></tr>
</table>
<p><b>Contents</b> </p><ol>
<li>
<a class="el" href="../../dd/d81/chapter3.html#section3_1">Symbolic expressions</a> </li>
<li>
<a class="el" href="../../dd/d81/chapter3.html#section3_2">Functions</a> <ul>
<li>
<a class="el" href="../../dd/d81/chapter3.html#subsection3_2_1">Numerical evaluation</a> </li>
<li>
<a class="el" href="../../dd/d81/chapter3.html#subsection3_2_2">Symbolic evaluation</a> </li>
</ul>
</li>
<li>
<a class="el" href="../../dd/d81/chapter3.html#section3_3">Calculating derivatives</a> <ul>
<li>
<a class="el" href="../../dd/d81/chapter3.html#subsection3_3_1">Forward differentiation</a> </li>
<li>
<a class="el" href="../../dd/d81/chapter3.html#subsection3_3_2">Backward (adjoint) differentiation</a> </li>
<li>
<a class="el" href="../../dd/d81/chapter3.html#subsection3_3_3">Symbolic differentiation</a> </li>
</ul>
</li>
</ol>
<p>In CasADi a very powerful symbolic abstraction of mathematical functions is implemented. In this chapter we will learn how to create general functions out of our model equations, how to evaluate them and optionally their derivatives. We also give some instructional examples to make it more easily understandable. </p>
<h1><a class="anchor" id="section3_1"></a>
Symbolic expressions</h1>
<p>Normally, mathematical expressions represent operations between variables and parameters. In order to build up our models, we need to have a computer-based abstraction of these. In CasADi the <a class="el" href="../../d7/d23/namespacecasadi.html#a77ea10c3c8f78d7a80e15b83af5b7a82">casadi::SX</a> class provides us exactly these building blocks. We create a simple expression: </p><table border="0" style="border-style: dotted; border-width: 1px;">
<tr>
<td>Example:</td><td>Output: </td></tr>
<tr style="vertical-align: top;">
<td><div class="fragment"><div class="line"> 1  #include <span class="stringliteral">&quot;casadi/sx/sx.hpp&quot;</span></div>
<div class="line"> 2  <span class="keyword">using namespace </span><a class="code" href="../../d7/d23/namespacecasadi.html">casadi</a>;</div>
<div class="line"> 3  <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]){</div>
<div class="line"> 4     <a class="code" href="../../d7/d23/namespacecasadi.html#a77ea10c3c8f78d7a80e15b83af5b7a82">SX</a> x(<span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line"> 5     <a class="code" href="../../d7/d23/namespacecasadi.html#a77ea10c3c8f78d7a80e15b83af5b7a82">SX</a> expr;</div>
<div class="line"> 6     cout &lt;&lt; <span class="stringliteral">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; endl;</div>
<div class="line"> 7     cout &lt;&lt; <span class="stringliteral">&quot;expr: &quot;</span> &lt;&lt; expr &lt;&lt; endl;</div>
<div class="line"> 8     expr = 3.0 * x + pow(x, 2) - sin(x);</div>
<div class="line"> 9     cout &lt;&lt; <span class="stringliteral">&quot;expr: &quot;</span> &lt;&lt; expr &lt;&lt; endl;</div>
<div class="line">10     <a class="code" href="../../d7/d23/namespacecasadi.html#a77ea10c3c8f78d7a80e15b83af5b7a82">SX</a> y(<span class="stringliteral">&quot;y&quot;</span>);</div>
<div class="line">11     expr += y / 2 / x;</div>
<div class="line">12     cout &lt;&lt; <span class="stringliteral">&quot;expr: &quot;</span> &lt;&lt; expr &lt;&lt; endl;</div>
<div class="line">13  }</div>
<div class="ttc" id="anamespacecasadi_html"><div class="ttname"><a href="../../d7/d23/namespacecasadi.html">casadi</a></div><div class="ttdoc">The casadi namespace.</div><div class="ttdef"><b>Definition:</b> <a href="../../db/da5/binary__mx__impl_8hpp_source.html#l00036">binary_mx_impl.hpp:36</a></div></div>
<div class="ttc" id="anamespacecasadi_html_a77ea10c3c8f78d7a80e15b83af5b7a82"><div class="ttname"><a href="../../d7/d23/namespacecasadi.html#a77ea10c3c8f78d7a80e15b83af5b7a82">casadi::SX</a></div><div class="ttdeci">Matrix&lt; SXElem &gt; SX</div><div class="ttdef"><b>Definition:</b> <a href="../../d5/d46/sx__fwd_8hpp_source.html#l00036">sx_fwd.hpp:32</a></div></div>
</div><!-- fragment -->  </td><td><div class="fragment"><div class="line">x: x</div>
<div class="line">expr: nan</div>
<div class="line">expr: (((3*x)+(x*x))-sin(x))</div>
<div class="line">expr: ((((3*x)+(x*x))-sin(x))+((y/2)/x))</div>
</div><!-- fragment -->   </td></tr>
</table>
<p>On the 1st line we include the header file containing the <a class="el" href="../../d7/d23/namespacecasadi.html#a77ea10c3c8f78d7a80e15b83af5b7a82">casadi::SX</a> class, on the 4th the <code>x</code> object is created and from here on the string <code>"x"</code> is assigned to this variable. We can also create <a class="el" href="../../d7/d23/namespacecasadi.html#a77ea10c3c8f78d7a80e15b83af5b7a82">casadi::SX</a> objects by invoking the default constructor (line 5), although this variable is not initialized to any symbolic expression at this time. The <code>expr</code> object is initialized on line 8, while from the line 10 on we extend our expression with a <code>y</code> variable. One can always check whether an expression is correct by simply printing it to the standard output. With the use of <a class="el" href="../../d7/d23/namespacecasadi.html#a77ea10c3c8f78d7a80e15b83af5b7a82">casadi::SX</a> objects and the <code>+ - * / += -= *= /= exp log sqrt sin pow</code> etc. operations we can build up a wide range of mathemetical expressions. We can also create a vector of expressions if needed, although each element must be initialized that may be carried out by the casadi::make_symbolic() function. Now we demonstrate how this works. </p><table border="0" style="border-style: dotted; border-width: 1px;">
</table>
<p>Example:</p>
<p>Output: <br  />
 </p>
<div class="fragment"><div class="line">1  #include <span class="stringliteral">&quot;casadi/sx/sx.hpp&quot;</span></div>
<div class="line">2  #include <span class="stringliteral">&quot;casadi/sx/sx_tools.hpp&quot;</span></div>
<div class="line">3  </div>
<div class="line">4  ...</div>
<div class="line">5  vector&lt;SX&gt; z(10);</div>
<div class="line">6  make_symbolic(z.begin(), z.end(), <span class="stringliteral">&quot;z&quot;</span>);</div>
<div class="line">7  cout &lt;&lt; <span class="stringliteral">&quot;z[4]: &quot;</span> &lt;&lt; z[4] &lt;&lt; endl;</div>
<div class="line">8  ...</div>
</div><!-- fragment -->  <div class="fragment"><div class="line">z[4]: z_4</div>
</div><!-- fragment -->   <p>After invoking make_symbolic (line 6) the elements of <code>z</code> are assigned to <code>z_0, z_1, ...</code> and can be used later on in modelling. </p>
<h1><a class="anchor" id="section3_2"></a>
Functions</h1>
<p>Now that we can build up mathematical expressions we would like to evaluate them symbolically or numerically. We will see how this can be done with the casadi::SXFunction object, which can represent mathematical functions that has prototype <img class="formulaInl" alt="$\mathbb{R} \rightarrow \mathbb{R}$" src="../../form_14.png" width="39" height="10"/>, <img class="formulaInl" alt="$\mathbb{R}^n \rightarrow \mathbb{R}$" src="../../form_15.png" width="45" height="10"/>, <img class="formulaInl" alt="$\mathbb{R}^n \rightarrow \mathbb{R}^m $" src="../../form_16.png" width="54" height="10"/> or <img class="formulaInl" alt="$\mathbb{R}^{n_1 \times n_2} \rightarrow \mathbb{R}^{m_1 \times m_2}$" src="../../form_17.png" width="104" height="10"/>. In the constructor of casadi::SXFunction one has to give two arguments. The first argument should contain all the variables that the function will depend on, and the second argument stores the function definition itself. The data type of the arguments may be various depending on the prototype of the function that is to be represented. Let's see some examples. </p>
<h2><a class="anchor" id="subsection3_2_1"></a>
Numerical evaluation</h2>
<p>Most often we would like to compute the value of a function in a certain point. In this subsection we will learn how to do that in case of different function prototypes. First we create and evaluate a simple scalar-scalar function numerically. </p><table border="0" style="border-style: dotted; border-width: 1px;">
</table>
<p>Example:</p>
<p>Output: <br  />
 </p>
<div class="fragment"><div class="line"> 1  #include <span class="stringliteral">&quot;casadi/sx/sx.hpp&quot;</span></div>
<div class="line"> 2  ...</div>
<div class="line"> 3  <a class="code" href="../../d7/d23/namespacecasadi.html#a77ea10c3c8f78d7a80e15b83af5b7a82">SX</a> x(<span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line"> 4  <a class="code" href="../../d7/d23/namespacecasadi.html#a77ea10c3c8f78d7a80e15b83af5b7a82">SX</a> f_expr = x * x - 3 * x + 2;</div>
<div class="line"> 5  SXFunction f(x, f_expr);</div>
<div class="line"> 6  f.init();</div>
<div class="line"> 7  <span class="keywordtype">double</span> d = 10.0;</div>
<div class="line"> 8  f.setInput(d);</div>
<div class="line"> 9  f.evaluate();</div>
<div class="line">10  cout &lt;&lt; <span class="stringliteral">&quot;Function value in x = &quot;</span> &lt;&lt; d &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; f.output() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --><p>  <br  />
 </p>
<div class="fragment"><div class="line">Function value in x = 10 : 72</div>
</div><!-- fragment -->   <p>On line 4 we create the expression that will represent our function. The SXFunction object is created (line 5) with the variable <code>x</code> and the <code>f_expr</code> object. Before passing any input to the function, we have to initialize it (see line 6). Then we set the input of the function, evaluate it and finally print the result.</p>
<p>Now we create a vector-scalar function that calculates the 2-norm of its argument. </p><table border="0" style="border-style: dotted; border-width: 1px;">
</table>
<p>Example:</p>
<p>Output: <br  />
 </p>
<div class="fragment"><div class="line"> 1  vector&lt;SX&gt; x(4);</div>
<div class="line"> 2  make_symbolic(x.begin(), x.end(), <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line"> 3  <a class="code" href="../../d7/d23/namespacecasadi.html#a77ea10c3c8f78d7a80e15b83af5b7a82">SX</a> f_expr = 0;</div>
<div class="line"> 4  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; x.size(); ++i){</div>
<div class="line"> 5     f_expr += x[i] * x[i];</div>
<div class="line"> 6  }</div>
<div class="line"> 7  f_expr = sqrt(f_expr);</div>
<div class="line"> 8  SXFunction f(x, f_expr);</div>
<div class="line"> 9  f.init();</div>
<div class="line">10  vector&lt;double&gt; d(x.size());</div>
<div class="line">11  fill(d.begin(), d.end(), 3);</div>
<div class="line">12  f.setInput(d);</div>
<div class="line">13  f.evaluate();</div>
<div class="line">14  cout &lt;&lt; <span class="stringliteral">&quot;Function value: &quot;</span> &lt;&lt; f.output() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --><p>  <br  />
 </p>
<div class="fragment"><div class="line">Function value: 6</div>
</div><!-- fragment -->   <p>The principle is exactly the same, the only difference is that now we pass a <code>std::vector&lt;SX&gt;</code> in the first argument on line 8 and we provide a <code>std::vector&lt;double&gt;</code> as an input on line 12.</p>
<p>Now we define and evaluate a vector-vector function. </p><table border="0" style="border-style: dotted; border-width: 1px;">
</table>
<p>Example:</p>
<p>Output: <br  />
 </p>
<div class="fragment"><div class="line"> 1  vector&lt;SX&gt; x(3);</div>
<div class="line"> 2  make_symbolic(x.begin(), x.end(), <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line"> 3  vector&lt;SX&gt; f_expr(2);</div>
<div class="line"> 4  fill(f_expr.begin(), f_expr.end(), 0);</div>
<div class="line"> 5  f_expr[0] = x[0] + 2 * x[1];</div>
<div class="line"> 6  f_expr[1] = x[1] + 4 * exp(x[2]);</div>
<div class="line"> 7  SXFunction f(x, f_expr);</div>
<div class="line"> 8  f.init();</div>
<div class="line"> 9  vector&lt;double&gt; d(3);</div>
<div class="line">10  fill(d.begin(), d.end(), 2);</div>
<div class="line">11  f.setInput(d);</div>
<div class="line">12  f.evaluate();</div>
<div class="line">13  vector&lt;double&gt; value = f.output().data();</div>
<div class="line">14  cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; value.size() &lt;&lt; <span class="stringliteral">&quot;](&quot;</span>;</div>
<div class="line">15  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; value.size(); ++i){</div>
<div class="line">16     cout &lt;&lt; value[i] &lt;&lt; <span class="stringliteral">&quot;,&quot;</span>;</div>
<div class="line">17  }</div>
<div class="line">18  cout &lt;&lt; <span class="stringliteral">&quot;\b)\n&quot;</span>;</div>
</div><!-- fragment --><p>  <br  />
 </p>
<div class="fragment"><div class="line">[2](6,31.5562)</div>
</div><!-- fragment -->   <p>This time both arguments of the constructor on line 7 are <code>std::vector&lt;SX&gt;</code> and the function value is accessible via SXFunction.output().data() (line 13).</p>
<p>As the last example let's see a piece of code, where the function depends on a <code> std::vector&lt;std::vector&lt;SX&gt; &gt; </code>. Note that this covers the case when our function depends on a matrix. </p><table border="0" style="border-style: dotted; border-width: 1px;">
</table>
<p>Example:</p>
<p>Output: <br  />
 </p>
<div class="fragment"><div class="line"> 1  vector&lt;vector&lt;SX&gt; &gt; variables;</div>
<div class="line"> 2  vector&lt;SX&gt; x(3);</div>
<div class="line"> 3  make_symbolic(x.begin(), x.end(), <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line"> 4  variables.push_back(x);</div>
<div class="line"> 5  vector&lt;SX&gt; y(2);</div>
<div class="line"> 6  make_symbolic(y.begin(), y.end(), <span class="stringliteral">&quot;y&quot;</span>);</div>
<div class="line"> 7  variables.push_back(y);</div>
<div class="line"> 8  vector&lt;SX&gt; f_expr(2);</div>
<div class="line"> 9  f_expr[0] = x[0] + x[2] - sin(y[0]);</div>
<div class="line">10  f_expr[1] = cos(x[1] - y[1]);</div>
<div class="line">11  SXFunction f(variables, f_expr);</div>
<div class="line">12  f.init();</div>
<div class="line">13  vector&lt;double&gt; d0(3);</div>
<div class="line">14  fill(d0.begin(), d0.end(), 6.0);</div>
<div class="line">15  vector&lt;double&gt; d1(2);</div>
<div class="line">16  fill(d1.begin(), d1.end(), 3.0);</div>
<div class="line">17  f.setInput(d0, 0);</div>
<div class="line">18  f.setInput(d1, 1);</div>
<div class="line">19  f.evaluate();</div>
<div class="line">20  vector&lt;double&gt; value = f.output().data();</div>
<div class="line">21  cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; value.size() &lt;&lt; <span class="stringliteral">&quot;](&quot;</span>;</div>
<div class="line">22  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; value.size(); ++i){</div>
<div class="line">23     cout &lt;&lt; value[i] &lt;&lt; <span class="stringliteral">&quot;,&quot;</span>;</div>
<div class="line">24  }</div>
<div class="line">25  cout &lt;&lt; <span class="stringliteral">&quot;\b)\n&quot;</span>;</div>
</div><!-- fragment --><p>  <br  />
 </p>
<div class="fragment"><div class="line">[2](11.8589,-0.989992)</div>
</div><!-- fragment -->   <p>In variable <code>variables</code> we collect vectors of SX objects. On line 17 and 18 you can notice a new argument (which was always 0 until now) that addresses an input vector. In this example on the first coordinate we have a 3 long vector, on the second we have a 2 long vector, which correspond to the function definition (line 11). It is important to understand the concept of functions depending on matrices, because, as it will be shown later on (see <a class="el" href="../../dc/d18/chapter4.html">Integrators</a>), integrators are exactly of this type.</p>
<h2><a class="anchor" id="subsection3_2_2"></a>
Symbolic evaluation</h2>
<p>One might also wish to replace certain variables in a symbolic expression with some other variables or with more complex expressions. This may be carried out easily by the use of symbolic evaluation, we use the casadi::SXFunction::eval() member function. </p><table border="0" style="border-style: dotted; border-width: 1px;">
</table>
<p>Example:</p>
<p>Output: <br  />
 </p>
<div class="fragment"><div class="line"> 1  vector&lt;SX&gt; x(3);</div>
<div class="line"> 2  make_symbolic(x.begin(), x.end(), <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line"> 3  vector&lt;SX&gt; f_expr(2);</div>
<div class="line"> 4  f_expr[0] = x[0] + 5 * x[1];</div>
<div class="line"> 5  f_expr[1] = x[0] + cos(x[2]);</div>
<div class="line"> 6  SXFunction f(x, f_expr);</div>
<div class="line"> 7  f.init();</div>
<div class="line"> 8  vector&lt;SX&gt; y = x;</div>
<div class="line"> 9  y[0] = x[1] + pow(x[2], 3);</div>
<div class="line">10  vector&lt;SX&gt; f_expr_subs = f.eval(y);</div>
<div class="line">11  cout &lt;&lt; f_expr[0] &lt;&lt; <span class="stringliteral">&quot; --&gt; &quot;</span> &lt;&lt; f_expr_subs[0] &lt;&lt; endl;</div>
<div class="line">12  cout &lt;&lt; f_expr[1] &lt;&lt; <span class="stringliteral">&quot; --&gt; &quot;</span> &lt;&lt; f_expr_subs[1] &lt;&lt; endl;</div>
</div><!-- fragment --><p>  <br  />
 </p>
<div class="fragment"><div class="line">(x_0+(5*x_1)) --&gt; ((x_1+(x_2*(x_2*x_2)))+(5*x_1))</div>
<div class="line">(x_0+cos(x_2)) --&gt; ((x_1+(x_2*(x_2*x_2)))+cos(x_2))</div>
</div><!-- fragment -->   <p>First we create a function depending on the vector <code>x</code> (line 1-7), then we create a vector of SX objects, whose size correspond to the function definition and we modify the first element by an arbitrary expression (line 9). As a result we get back the function expression in which the substitution has already been committed. </p>
<h1><a class="anchor" id="section3_3"></a>
Calculating derivatives</h1>
<p>In this section we will learn how to calculate first-order derivatives of general functions. Within CasADi derivatives of general functions may be calculated in two ways. First, the derivatives are calculated numerically based on automatic differentiation, which has two modes forward and backward. Second, knowing the symbolic representation of the functions one may differentiate symbolically. </p>
<h2><a class="anchor" id="subsection3_3_1"></a>
Forward differentiation</h2>
<p>In the forward mode one can calculate the directional derivative <img class="formulaInl" alt="$J p$" src="../../form_18.png" width="15" height="13"/>, where <img class="formulaInl" alt="$J$" src="../../form_19.png" width="8" height="10"/> is the Jacobian of a <img class="formulaInl" alt="$f: \mathbb{R}^n \rightarrow \mathbb{R}^m$" src="../../form_20.png" width="70" height="13"/> and <img class="formulaInl" alt="$p \in \mathbb{R}^m$" src="../../form_21.png" width="40" height="13"/> is the direction. In the following code we calculate the full Jacobian providing multiple directions. </p><table border="0" style="border-style: dotted; border-width: 1px;">
</table>
<p>Example:</p>
<p>Output: <br  />
 </p>
<div class="fragment"><div class="line"> 1  vector&lt;SX&gt; x(3);</div>
<div class="line"> 2  make_symbolic(x.begin(), x.end(), <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line"> 3  vector&lt;SX&gt; f_expr(2);</div>
<div class="line"> 4  f_expr[0] = x[0] + 5 * x[1];</div>
<div class="line"> 5  f_expr[1] = x[0] + cos(x[2]);</div>
<div class="line"> 6  SXFunction f(x, f_expr);</div>
<div class="line"> 7  f.setOption(<span class="stringliteral">&quot;number_of_fwd_dir&quot;</span>, (<span class="keywordtype">int</span>)x.size());</div>
<div class="line"> 8  f.init();</div>
<div class="line"> 9  vector&lt;double&gt; d(x.size());</div>
<div class="line">10  fill(d.begin(), d.end(), 4.0);</div>
<div class="line">11  f.setInput(d);</div>
<div class="line">12  vector&lt;double&gt; fwd_seed(x.size());</div>
<div class="line">13  fill(fwd_seed.begin(), fwd_seed.end(), 0);</div>
<div class="line">14  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; x.size(); ++i){</div>
<div class="line">15     fwd_seed[i] = 1;</div>
<div class="line">16     f.setFwdSeed(fwd_seed, 0, i);</div>
<div class="line">17     fwd_seed[i] = 0;</div>
<div class="line">18  }</div>
<div class="line">19  f.evaluate(x.size(), 0);</div>
<div class="line">20  cout &lt;&lt; <span class="stringliteral">&quot;Function value: &quot;</span> &lt;&lt; f.output() &lt;&lt; endl;</div>
<div class="line">21  vector&lt;double&gt; jacobian_column;</div>
<div class="line">22  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; x.size(); ++i){</div>
<div class="line">23     jacobian_column = f.fwdSens(0, i).data();</div>
<div class="line">24     cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; jacobian_column.size() &lt;&lt; <span class="stringliteral">&quot;](&quot;</span>;</div>
<div class="line">25     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; jacobian_column.size(); ++j){</div>
<div class="line">26        cout &lt;&lt; jacobian_column[j] &lt;&lt; <span class="stringliteral">&quot;,&quot;</span>;</div>
<div class="line">27     }</div>
<div class="line">28     cout &lt;&lt; <span class="stringliteral">&quot;\b)\n&quot;</span>;</div>
<div class="line">29  }</div>
</div><!-- fragment --><p>  <br  />
 </p>
<div class="fragment"><div class="line">Function value: [24,3.34636]</div>
<div class="line">[2](1,1)</div>
<div class="line">[2](5,0)</div>
<div class="line">[2](0,0.756802)</div>
</div><!-- fragment -->   <p>The first new thing is on line 7, we set an option called <code>number_of_fwd_dir</code> to the number of the forward directions in which we would like to differentiate. On line 16 we are inside a for loop and we provide the directions; now only columns of the identity matrix. The way of evaluation is also slightly different (line 19), so far we haven't given any arguments. The first argument indicates the number of forward derivatives to be evaluated, the second is just the same, but with adjoint derivatives. In any case, the function itself is evaluated. We can collect our directional derivatives by the casadi::SXFunction::fwdSens() member function (line 23). Note that the first argument addresses the the matrix input. Since we have only vector input now, this is always zero.</p>
<h2><a class="anchor" id="subsection3_3_2"></a>
Backward (adjoint) differentiation</h2>
<p>In this mode of derivative calculation one can calculate <img class="formulaInl" alt="$J^T p$" src="../../form_22.png" width="23" height="14"/>. Mutiple directions are not yet supported by CasADi. The code is as follows:</p>
<table border="0" style="border-style: dotted; border-width: 1px;">
</table>
<p>Example:</p>
<p>Output: <br  />
 </p>
<div class="fragment"><div class="line"> 1  vector&lt;SX&gt; x(3);</div>
<div class="line"> 2  make_symbolic(x.begin(), x.end(), <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line"> 3  vector&lt;SX&gt; f_expr(2);</div>
<div class="line"> 4  f_expr[0] = x[0] + 5 * x[1];</div>
<div class="line"> 5  f_expr[1] = x[0] + cos(x[2]);</div>
<div class="line"> 6  SXFunction f(x, f_expr);</div>
<div class="line"> 7  f.setOption(<span class="stringliteral">&quot;number_of_adj_dir&quot;</span>, 1);</div>
<div class="line"> 8  f.init();</div>
<div class="line"> 9  vector&lt;double&gt; d(x.size());</div>
<div class="line">10  fill(d.begin(), d.end(), 4.0);</div>
<div class="line">11  f.setInput(d);</div>
<div class="line">12  vector&lt;double&gt; adj_seed(f_expr.size());</div>
<div class="line">13  fill(adj_seed.begin(), adj_seed.end(), 1);</div>
<div class="line">14  f.setAdjSeed(adj_seed, 0, 0);</div>
<div class="line">15  f.evaluate(0, 1);</div>
<div class="line">16  cout &lt;&lt; <span class="stringliteral">&quot;Function value: &quot;</span> &lt;&lt; f.output() &lt;&lt; endl;</div>
<div class="line">17  cout &lt;&lt; <span class="stringliteral">&quot;Adjoint derivative: &quot;</span> &lt;&lt; f.adjSens(0, 0) &lt;&lt; endl;</div>
</div><!-- fragment --><p>  <br  />
 </p>
<div class="fragment"><div class="line">Function value: [24,3.34636]</div>
<div class="line">Adjoint derivative: [2,5,0.756802]</div>
</div><!-- fragment -->   <p>This time we set the option <code>number_of_adj_dir</code> (greater than 1 throws an error) and we invoke SXFunction::evaluate(0, 1). The adjoint derivative we can access by the casadi::SXFunction::adjSens(...) method.</p>
<h2><a class="anchor" id="subsection3_3_3"></a>
Symbolic differentiation</h2>
<p>The second way one can differentiate is by symbolic manipulation. The result of this approach is nothing else than a function symbolically representing the first derivative of the original function. The following example demonstrates this. </p><table border="0" style="border-style: dotted; border-width: 1px;">
</table>
<p>Example:</p>
<p>Output: <br  />
 </p>
<div class="fragment"><div class="line"> 1  vector&lt;SX&gt; variables;</div>
<div class="line"> 2  vector&lt;SX&gt; x(3);</div>
<div class="line"> 3  make_symbolic(x, <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line"> 4  variables = x;</div>
<div class="line"> 5  vector&lt;SX&gt; f_expr(2);</div>
<div class="line"> 6  f_expr[0] = x[0] + x[2] - sin(x[0]);</div>
<div class="line"> 7  f_expr[1] = cos(x[1] - x[2] * x[0]);</div>
<div class="line"> 8  SXFunction f(variables, f_expr);</div>
<div class="line"> 9  f.init();</div>
<div class="line">10  SXFunction f_der = f.jacobian();</div>
<div class="line">11  cout &lt;&lt; <span class="stringliteral">&quot;f: &quot;</span> &lt;&lt; f.mx_out2() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; </div>
<div class="line">12  cout &lt;&lt; <span class="stringliteral">&quot;f_der: &quot;</span> &lt;&lt; f_der.mx_out2() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">13  vector&lt;double&gt; d0(3);</div>
<div class="line">14  fill(d0.begin(), d0.end(), 6.0);</div>
<div class="line">15  f_der.init();</div>
<div class="line">16  f_der.setInput(d0);</div>
<div class="line">17  f_der.evaluate();</div>
<div class="line">18  cout &lt;&lt; <span class="stringliteral">&quot;Jacobian: &quot;</span> &lt;&lt; f_der.output() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; </div>
</div><!-- fragment --><p>  <br  />
 </p>
<div class="fragment"><div class="line">f: [((x_0+x_2)-sin(x_0)),cos((x_1-(x_2*x_0)))]</div>
<div class="line">f_der: [[((-cos(x_0))+1),0,1],[(x_2*sin((x_1-(x_2*x_0)))),(-sin((x_1-(x_2*x_0)))),(x_0*sin((x_1-(x_2*x_0))))]]</div>
<div class="line">Jacobian: [[0.0398297,0,1],[5.92819,-0.988032,5.92819]]</div>
</div><!-- fragment -->   <p>The code is very self-explanatory, we create a vector-vector function (line 1-9) and invoke the SXFunction::jacobian() method, which returns an SXFunction object. This object, since it's a function itself, can be evaluated and differentiated again. This way one may calculate higher-order derivatives. </p><table style="width: 100%;">
<tr>
<td style="text-align: left;">Previous chapter: <a class="el" href="../../d3/def/chapter2.html">Installation</a> </td><td style="text-align: right;">Next chapter: <a class="el" href="../../dc/d18/chapter4.html">Integrators</a>  </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</body>
</html>
