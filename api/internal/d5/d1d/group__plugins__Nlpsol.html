<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>CasADi: Plugins_Nlpsol</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<link rel="search" href="../../search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="CasADi"/>
<link href="../../customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://casadi.org"><img src="/api/html/casadi.png" alt="CasADi" height="55px"/></a>&#160;<span>internal API<sup style="font-size:30%">(<a href="../../../html/index.html">switch to public</a>)</sup></span> - <a href="https://github.com/casadi/casadi/tree/f959d3175a444d763e4eda4aece48f4c5f4a6f90" id="f959d3175a444d763e4eda4aece48f4c5f4a6f90" >revision 3.7.2</a></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Plugins_Nlpsol</div>  </div>
</div><!--header-->
<div class="contents">
<hr  />
  <h4>ampl <a class="anchor" id="plugin_Nlpsol_ampl"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Interface to AMPL</p>
<dl class="section author"><dt>Author</dt><dd>Joel Andersson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017</dd></dl>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_22b">https://github.com/casadi/casadi/wiki/L_22b</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>solver</td><td>OT_STRING</td><td>AMPL solver binary </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>blocksqp <a class="anchor" id="plugin_Nlpsol_blocksqp"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>This is a modified version of blockSQP by Janka et al.</p>
<dl class="section author"><dt>Author</dt><dd>Dennis Janka, Joel Andersson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2012-2015, 2016</dd></dl>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_224">https://github.com/casadi/casadi/wiki/L_224</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>block_hess</td><td>OT_INT</td><td>Blockwise Hessian approximation? </td></tr>
<tr>
<td>col_eps</td><td>OT_DOUBLE</td><td>Epsilon for COL scaling strategy </td></tr>
<tr>
<td>col_tau1</td><td>OT_DOUBLE</td><td>tau1 for COL scaling strategy </td></tr>
<tr>
<td>col_tau2</td><td>OT_DOUBLE</td><td>tau2 for COL scaling strategy </td></tr>
<tr>
<td>conv_strategy</td><td>OT_INT</td><td>Convexification strategy </td></tr>
<tr>
<td>delta</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>delta_h0</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>eps</td><td>OT_DOUBLE</td><td>Values smaller than this are regarded as numerically zero </td></tr>
<tr>
<td>eta</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>fallback_scaling</td><td>OT_INT</td><td>If indefinite update is used, the type of fallback strategy </td></tr>
<tr>
<td>fallback_update</td><td>OT_INT</td><td>If indefinite update is used, the type of fallback strategy </td></tr>
<tr>
<td>gamma_f</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>gamma_theta</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>globalization</td><td>OT_BOOL</td><td>Enable globalization </td></tr>
<tr>
<td>hess_damp</td><td>OT_INT</td><td>Activate Powell damping for BFGS </td></tr>
<tr>
<td>hess_damp_fac</td><td>OT_DOUBLE</td><td>Damping factor for BFGS Powell modification </td></tr>
<tr>
<td>hess_lim_mem</td><td>OT_INT</td><td>Full or limited memory </td></tr>
<tr>
<td>hess_memsize</td><td>OT_INT</td><td>Memory size for L-BFGS updates </td></tr>
<tr>
<td>hess_scaling</td><td>OT_INT</td><td>Scaling strategy for Hessian approximation </td></tr>
<tr>
<td>hess_update</td><td>OT_INT</td><td>Type of Hessian approximation </td></tr>
<tr>
<td>ini_hess_diag</td><td>OT_DOUBLE</td><td>Initial Hessian guess: diagonal matrix diag(iniHessDiag) </td></tr>
<tr>
<td>kappa_f</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>kappa_minus</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>kappa_plus</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>kappa_plus_max</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>kappa_soc</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>linsol</td><td>OT_STRING</td><td>The linear solver to be used by the QP method </td></tr>
<tr>
<td>max_consec_reduced_steps</td><td>OT_INT</td><td>Maximum number of consecutive reduced steps </td></tr>
<tr>
<td>max_consec_skipped_updates</td><td>OT_INT</td><td>Maximum number of consecutive skipped updates </td></tr>
<tr>
<td>max_conv_qp</td><td>OT_INT</td><td>How many additional QPs may be solved for convexification per iteration? </td></tr>
<tr>
<td>max_it_qp</td><td>OT_INT</td><td>Maximum number of QP iterations per SQP iteration </td></tr>
<tr>
<td>max_iter</td><td>OT_INT</td><td>Maximum number of SQP iterations </td></tr>
<tr>
<td>max_line_search</td><td>OT_INT</td><td>Maximum number of steps in line search </td></tr>
<tr>
<td>max_soc_iter</td><td>OT_INT</td><td>Maximum number of SOC line search iterations </td></tr>
<tr>
<td>max_time_qp</td><td>OT_DOUBLE</td><td>Maximum number of time in seconds per QP solve per SQP iteration </td></tr>
<tr>
<td>nlinfeastol</td><td>OT_DOUBLE</td><td>Nonlinear feasibility tolerance </td></tr>
<tr>
<td>obj_lo</td><td>OT_DOUBLE</td><td>Lower bound on objective function [-inf] </td></tr>
<tr>
<td>obj_up</td><td>OT_DOUBLE</td><td>Upper bound on objective function [inf] </td></tr>
<tr>
<td>opttol</td><td>OT_DOUBLE</td><td>Optimality tolerance </td></tr>
<tr>
<td>print_header</td><td>OT_BOOL</td><td>Print solver header at startup </td></tr>
<tr>
<td>print_iteration</td><td>OT_BOOL</td><td>Print SQP iterations </td></tr>
<tr>
<td>print_maxit_reached</td><td>OT_BOOL</td><td>Print error when maximum number of SQP iterations reached </td></tr>
<tr>
<td>qp_init</td><td>OT_BOOL</td><td>Use warmstarting </td></tr>
<tr>
<td>qpsol</td><td>OT_STRING</td><td>The QP solver to be used by the SQP method </td></tr>
<tr>
<td>qpsol_options</td><td>OT_DICT</td><td>Options to be passed to the QP solver </td></tr>
<tr>
<td>restore_feas</td><td>OT_BOOL</td><td>Use feasibility restoration phase </td></tr>
<tr>
<td>rho</td><td>OT_DOUBLE</td><td>Feasibility restoration phase parameter </td></tr>
<tr>
<td>s_f</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>s_theta</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>schur</td><td>OT_BOOL</td><td>Use qpOASES Schur compliment approach </td></tr>
<tr>
<td>skip_first_globalization</td><td>OT_BOOL</td><td>No globalization strategy in first iteration </td></tr>
<tr>
<td>theta_max</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>theta_min</td><td>OT_DOUBLE</td><td>Filter line search parameter, cf. IPOPT paper </td></tr>
<tr>
<td>warmstart</td><td>OT_BOOL</td><td>Use warmstarting </td></tr>
<tr>
<td>which_second_derv</td><td>OT_INT</td><td>For which block should second derivatives be provided by the user </td></tr>
<tr>
<td>zeta</td><td>OT_DOUBLE</td><td>Feasibility restoration phase parameter </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>bonmin <a class="anchor" id="plugin_Nlpsol_bonmin"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>When in warmstart mode, output NLPSOL_LAM_X may be used as input</p>
<p>NOTE: Even when max_iter == 0, it is not guaranteed that input(NLPSOL_X0) == output(NLPSOL_X). Indeed if bounds on X or constraints are unmet, they will differ.</p>
<p>For a good tutorial on BONMIN, see <a href="https://drops.dagstuhl.de/storage/16dagstuhl-seminar-proceedings/dsp-vol09061/DagSemProc.09061.16/DagSemProc.09061.16.pdf">https://drops.dagstuhl.de/storage/16dagstuhl-seminar-proceedings/dsp-vol09061/DagSemProc.09061.16/DagSemProc.09061.16.pdf</a></p>
<p>A good resource about the algorithms in BONMIN is: Wachter and L. T. Biegler, On the Implementation of an Interior-Point Filter Line-Search Algorithm for Large-Scale Nonlinear Programming, Mathematical Programming 106(1), pp. 25-57, 2006 (As Research Report RC 23149, IBM T. J. Watson Research Center, Yorktown, USA</p>
<p>Caveats:</p><ul>
<li><p class="startli">with default options, multipliers for the decision variables are wrong for equality constraints. Change the 'fixed_variable_treatment' to 'make_constraint' or 'relax_bounds' to obtain correct results.</p>
<p class="startli">Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_223">https://github.com/casadi/casadi/wiki/L_223</a></p>
</li>
</ul>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>bonmin</td><td>OT_DICT</td><td>Options to be passed to BONMIN </td></tr>
<tr>
<td>con_integer_md</td><td>OT_DICT</td><td>Integer metadata (a dictionary with lists of integers) about constraints to be passed to BONMIN </td></tr>
<tr>
<td>con_numeric_md</td><td>OT_DICT</td><td>Numeric metadata (a dictionary with lists of reals) about constraints to be passed to BONMIN </td></tr>
<tr>
<td>con_string_md</td><td>OT_DICT</td><td>String metadata (a dictionary with lists of strings) about constraints to be passed to BONMIN </td></tr>
<tr>
<td>grad_f</td><td>OT_FUNCTION</td><td>Function for calculating the gradient of the objective (column, autogenerated by default) </td></tr>
<tr>
<td>grad_f_options</td><td>OT_DICT</td><td>Options for the autogenerated gradient of the objective. </td></tr>
<tr>
<td>hess_lag</td><td>OT_FUNCTION</td><td>Function for calculating the Hessian of the Lagrangian (autogenerated by default) </td></tr>
<tr>
<td>hess_lag_options</td><td>OT_DICT</td><td>Options for the autogenerated Hessian of the Lagrangian. </td></tr>
<tr>
<td>jac_g</td><td>OT_FUNCTION</td><td>Function for calculating the Jacobian of the constraints (autogenerated by default) </td></tr>
<tr>
<td>jac_g_options</td><td>OT_DICT</td><td>Options for the autogenerated Jacobian of the constraints. </td></tr>
<tr>
<td>pass_nonlinear_constraints</td><td>OT_BOOL</td><td>Pass list of constraints entering nonlinearly to BONMIN </td></tr>
<tr>
<td>pass_nonlinear_variables</td><td>OT_BOOL</td><td>Pass list of variables entering nonlinearly to BONMIN </td></tr>
<tr>
<td>sos1_groups</td><td>OT_INTVECTORVECTOR</td><td>Options for the autogenerated gradient of the objective. </td></tr>
<tr>
<td>sos1_priorities</td><td>OT_INTVECTOR</td><td>Options for the autogenerated gradient of the objective. </td></tr>
<tr>
<td>sos1_weights</td><td>OT_DOUBLEVECTORVECTOR</td><td>Options for the autogenerated gradient of the objective. </td></tr>
<tr>
<td>var_integer_md</td><td>OT_DICT</td><td>Integer metadata (a dictionary with lists of integers) about variables to be passed to BONMIN </td></tr>
<tr>
<td>var_numeric_md</td><td>OT_DICT</td><td>Numeric metadata (a dictionary with lists of reals) about variables to be passed to BONMIN </td></tr>
<tr>
<td>var_string_md</td><td>OT_DICT</td><td>String metadata (a dictionary with lists of strings) about variables to be passed to BONMIN </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>fatrop <a class="anchor" id="plugin_Nlpsol_fatrop"></a> </h4>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>N</td><td>OT_INT</td><td>OCP horizon </td></tr>
<tr>
<td>convexify_margin</td><td>OT_DOUBLE</td><td>When using a convexification strategy, make sure that the smallest eigenvalue is at least this (default: 1e-7). </td></tr>
<tr>
<td>convexify_strategy</td><td>OT_STRING</td><td>NONE|regularize|eigen-reflect|eigen-clip. Strategy to convexify the Lagrange Hessian before passing it to the solver. </td></tr>
<tr>
<td>debug</td><td>OT_BOOL</td><td>Produce debug information (default: false) </td></tr>
<tr>
<td>fatrop</td><td>OT_DICT</td><td>Options to be passed to fatrop </td></tr>
<tr>
<td>ng</td><td>OT_INTVECTOR</td><td>Number of non-dynamic constraints, length N+1 </td></tr>
<tr>
<td>nu</td><td>OT_INTVECTOR</td><td>Number of controls, length N+1 </td></tr>
<tr>
<td>nx</td><td>OT_INTVECTOR</td><td>Number of states, length N+1 </td></tr>
<tr>
<td>structure_detection</td><td>OT_STRING</td><td>NONE | auto | manual </td></tr>
</table>
</dd></dl>
<p>Fatrop is a solver developed at KU Leuven by Lander Vanroye and Wilm Decre. The algorithm is based on IPOPT, but the linear algebra is much more efficient.</p>
<p>With structure_detection = 'none' (default), it will behave as a general-purpose dense nonlinear program solver.</p>
<p>With structure_detection = 'manual', you can specify a block structure.</p>
<p>Let's say you perform multiply shooting with a system</p>
<p>x_k+1 = A_k x_k + B_k u_k</p>
<p>Suppose your constraint Jacobian looks like: </p><pre class="fragment"> nx0  nu0  nx1  nu1  nx2  nu2
 -----------------------------
</pre><p> nx1 |A0 B0 I0 <br  />
 ng1 |C0 D0 <br  />
 nx2 | A1 B1 I1 <br  />
 ng2 | C1 D1 <br  />
 ng3 | C2 D2</p>
<p>with n* capturing the number of states, inputs, and constraints in each block.</p>
<p>You can then specify this structure with:</p>
<p>N = 2 nx = [nx0 ,nx1, nx2] nu = [nu0, nu1, nu2] ng = [ng1, ng2, ng3]</p>
<p>With structure_detection = 'auto', the block-defining parameters nx, nu, ng, and N are automatically detected from the sparsity pattern.</p>
<hr  />
  <h4>ipopt <a class="anchor" id="plugin_Nlpsol_ipopt"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>When in warmstart mode, output NLPSOL_LAM_X may be used as input</p>
<p>NOTE: Even when max_iter == 0, it is not guaranteed that input(NLPSOL_X0) == output(NLPSOL_X). Indeed if bounds on X or constraints are unmet, they will differ.</p>
<p>For a good tutorial on IPOPT, see <a href="https://drops.dagstuhl.de/storage/16dagstuhl-seminar-proceedings/dsp-vol09061/DagSemProc.09061.16/DagSemProc.09061.16.pdf">https://drops.dagstuhl.de/storage/16dagstuhl-seminar-proceedings/dsp-vol09061/DagSemProc.09061.16/DagSemProc.09061.16.pdf</a></p>
<p>A good resource about the algorithms in IPOPT is: Wachter and L. T. Biegler, On the Implementation of an Interior-Point Filter Line-Search Algorithm for Large-Scale Nonlinear Programming, Mathematical Programming 106(1), pp. 25-57, 2006 (As Research Report RC 23149, IBM T. J. Watson Research Center, Yorktown, USA</p>
<p>Caveats:</p><ul>
<li><p class="startli">with default options, multipliers for the decision variables are wrong for equality constraints. Change the 'fixed_variable_treatment' to 'make_constraint' or 'relax_bounds' to obtain correct results.</p>
<p class="startli">Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_21y">https://github.com/casadi/casadi/wiki/L_21y</a></p>
</li>
</ul>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>clip_inactive_lam</td><td>OT_BOOL</td><td>Explicitly set Lagrange multipliers to 0 when bound is deemed inactive (default: false). </td></tr>
<tr>
<td>con_integer_md</td><td>OT_DICT</td><td>Integer metadata (a dictionary with lists of integers) about constraints to be passed to IPOPT </td></tr>
<tr>
<td>con_numeric_md</td><td>OT_DICT</td><td>Numeric metadata (a dictionary with lists of reals) about constraints to be passed to IPOPT </td></tr>
<tr>
<td>con_string_md</td><td>OT_DICT</td><td>String metadata (a dictionary with lists of strings) about constraints to be passed to IPOPT </td></tr>
<tr>
<td>convexify_margin</td><td>OT_DOUBLE</td><td>When using a convexification strategy, make sure that the smallest eigenvalue is at least this (default: 1e-7). </td></tr>
<tr>
<td>convexify_strategy</td><td>OT_STRING</td><td>NONE|regularize|eigen-reflect|eigen-clip. Strategy to convexify the Lagrange Hessian before passing it to the solver. </td></tr>
<tr>
<td>grad_f</td><td>OT_FUNCTION</td><td>Function for calculating the gradient of the objective (column, autogenerated by default) </td></tr>
<tr>
<td>hess_lag</td><td>OT_FUNCTION</td><td>Function for calculating the Hessian of the Lagrangian (autogenerated by default) </td></tr>
<tr>
<td>inactive_lam_strategy</td><td>OT_STRING</td><td>Strategy to detect if a bound is inactive. RELTOL: use solver-defined constraint tolerance * inactive_lam_value|abstol: use inactive_lam_value </td></tr>
<tr>
<td>inactive_lam_value</td><td>OT_DOUBLE</td><td>Value used in inactive_lam_strategy (default: 10). </td></tr>
<tr>
<td>ipopt</td><td>OT_DICT</td><td>Options to be passed to IPOPT </td></tr>
<tr>
<td>jac_g</td><td>OT_FUNCTION</td><td>Function for calculating the Jacobian of the constraints (autogenerated by default) </td></tr>
<tr>
<td>max_iter_eig</td><td>OT_DOUBLE</td><td>Maximum number of iterations to compute an eigenvalue decomposition (default: 50). </td></tr>
<tr>
<td>pass_nonlinear_variables</td><td>OT_BOOL</td><td>Pass list of variables entering nonlinearly to IPOPT </td></tr>
<tr>
<td>var_integer_md</td><td>OT_DICT</td><td>Integer metadata (a dictionary with lists of integers) about variables to be passed to IPOPT </td></tr>
<tr>
<td>var_numeric_md</td><td>OT_DICT</td><td>Numeric metadata (a dictionary with lists of reals) about variables to be passed to IPOPT </td></tr>
<tr>
<td>var_string_md</td><td>OT_DICT</td><td>String metadata (a dictionary with lists of strings) about variables to be passed to IPOPT </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>knitro <a class="anchor" id="plugin_Nlpsol_knitro"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>KNITRO interface</p>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_22c">https://github.com/casadi/casadi/wiki/L_22c</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>complem_variables</td><td>OT_INTVECTORVECTOR</td><td>List of complementary constraints on simple bounds. Pair (i, j) encodes complementarity between the bounds on variable i and variable j. </td></tr>
<tr>
<td>contype</td><td>OT_INTVECTOR</td><td>Type of constraint </td></tr>
<tr>
<td>detect_linear_constraints</td><td>OT_BOOL</td><td>Detect type of constraints </td></tr>
<tr>
<td>knitro</td><td>OT_DICT</td><td>Options to be passed to KNITRO </td></tr>
<tr>
<td>options_file</td><td>OT_STRING</td><td>Read options from file (solver specific) </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>madnlp <a class="anchor" id="plugin_Nlpsol_madnlp"></a> </h4>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>convexify_margin</td><td>OT_DOUBLE</td><td>When using a convexification strategy, make sure that the smallest eigenvalue is at least this (default: 1e-7). </td></tr>
<tr>
<td>convexify_strategy</td><td>OT_STRING</td><td>NONE|regularize|eigen-reflect|eigen-clip. Strategy to convexify the Lagrange Hessian before passing it to the solver. </td></tr>
<tr>
<td>madnlp</td><td>OT_DICT</td><td>Options to be passed to madnlp </td></tr>
<tr>
<td>ng</td><td>OT_INTVECTOR</td><td>Number of constraints </td></tr>
<tr>
<td>nw</td><td>OT_INTVECTOR</td><td>Number of variables </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>snopt <a class="anchor" id="plugin_Nlpsol_snopt"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>SNOPT interface</p>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_22m">https://github.com/casadi/casadi/wiki/L_22m</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>snopt</td><td>OT_DICT</td><td>Options to be passed to SNOPT </td></tr>
<tr>
<td>start</td><td>OT_STRING</td><td>Warm-start options for Worhp: cold|warm|hot </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>worhp <a class="anchor" id="plugin_Nlpsol_worhp"></a> </h4>
<p>WORHP interface</p>
<p>Designed for Worhp 1.12</p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>worhp</td><td>OT_DICT</td><td>Options to be passed to WORHP </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>feasiblesqpmethod <a class="anchor" id="plugin_Nlpsol_feasiblesqpmethod"></a> </h4>
<dl class="section user"><dt></dt><dd>A textbook FeasibleSQPMethod</dd></dl>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_241">https://github.com/casadi/casadi/wiki/L_241</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>anderson_memory</td><td>OT_INT</td><td>Anderson memory. If Anderson is used default is 1, else default is 0. </td></tr>
<tr>
<td>contraction_acceptance_value</td><td>OT_DOUBLE</td><td>If the empirical contraction rate in the feasibility iterations is above this value in the heuristics the iterations are aborted. </td></tr>
<tr>
<td>convexify_margin</td><td>OT_DOUBLE</td><td>When using a convexification strategy, make sure that the smallest eigenvalue4 is at least this (default: 1e-7). </td></tr>
<tr>
<td>convexify_strategy</td><td>OT_STRING</td><td>NONE|regularize|eigen-reflect|eigen-clip. Strategy to convexify the Lagrange Hessian before passing it to the solver. </td></tr>
<tr>
<td>f</td><td>OT_FUNCTION</td><td>Function for calculating the objective function (autogenerated by default) </td></tr>
<tr>
<td>feas_tol</td><td>OT_DOUBLE</td><td>Feasibility tolerance. Below this tolerance an iterate is considered to be feasible. </td></tr>
<tr>
<td>g</td><td>OT_FUNCTION</td><td>Function for calculating the constraints (autogenerated by default) </td></tr>
<tr>
<td>grad_f</td><td>OT_FUNCTION</td><td>Function for calculating the gradient of the objective (autogenerated by default) </td></tr>
<tr>
<td>hess_lag</td><td>OT_FUNCTION</td><td>Function for calculating the Hessian of the Lagrangian (autogenerated by default) </td></tr>
<tr>
<td>hessian_approximation</td><td>OT_STRING</td><td>limited-memory|exact </td></tr>
<tr>
<td>init_feasible</td><td>OT_BOOL</td><td>Initialize the QP subproblems with a feasible initial value (default: false). </td></tr>
<tr>
<td>jac_g</td><td>OT_FUNCTION</td><td>Function for calculating the Jacobian of the constraints (autogenerated by default) </td></tr>
<tr>
<td>lbfgs_memory</td><td>OT_INT</td><td>Size of L-BFGS memory. </td></tr>
<tr>
<td>max_inner_iter</td><td>OT_DOUBLE</td><td>Maximum number of inner iterations. </td></tr>
<tr>
<td>max_iter</td><td>OT_INT</td><td>Maximum number of SQP iterations </td></tr>
<tr>
<td>max_iter_eig</td><td>OT_DOUBLE</td><td>Maximum number of iterations to compute an eigenvalue decomposition (default: 50). </td></tr>
<tr>
<td>merit_memory</td><td>OT_INT</td><td>Size of memory to store history of merit function values </td></tr>
<tr>
<td>min_iter</td><td>OT_INT</td><td>Minimum number of SQP iterations </td></tr>
<tr>
<td>optim_tol</td><td>OT_DOUBLE</td><td>Optimality tolerance. Below this value an iterate is considered to be optimal. </td></tr>
<tr>
<td>print_header</td><td>OT_BOOL</td><td>Print the header with problem statistics </td></tr>
<tr>
<td>print_iteration</td><td>OT_BOOL</td><td>Print the iterations </td></tr>
<tr>
<td>print_status</td><td>OT_BOOL</td><td>Print a status message after solving </td></tr>
<tr>
<td>qpsol</td><td>OT_STRING</td><td>The QP solver to be used by the SQP method [qpoases] </td></tr>
<tr>
<td>qpsol_options</td><td>OT_DICT</td><td>Options to be passed to the QP solver </td></tr>
<tr>
<td>solve_type</td><td>OT_STRING</td><td>The solver type: Either SQP or SLP. Defaults to SQP </td></tr>
<tr>
<td>tol_du</td><td>OT_DOUBLE</td><td>Stopping criterion for dual infeasability </td></tr>
<tr>
<td>tol_pr</td><td>OT_DOUBLE</td><td>Stopping criterion for primal infeasibility </td></tr>
<tr>
<td>tr_acceptance</td><td>OT_DOUBLE</td><td>Is the trust-region ratio above this value, the step is accepted. </td></tr>
<tr>
<td>tr_alpha1</td><td>OT_DOUBLE</td><td>Lower alpha in trust-region size criterion. </td></tr>
<tr>
<td>tr_alpha2</td><td>OT_DOUBLE</td><td>Upper alpha in trust-region size criterion. </td></tr>
<tr>
<td>tr_eta1</td><td>OT_DOUBLE</td><td>Lower eta in trust-region acceptance criterion. </td></tr>
<tr>
<td>tr_eta2</td><td>OT_DOUBLE</td><td>Upper eta in trust-region acceptance criterion. </td></tr>
<tr>
<td>tr_rad0</td><td>OT_DOUBLE</td><td>Initial trust-region radius. </td></tr>
<tr>
<td>tr_rad_max</td><td>OT_DOUBLE</td><td>Maximum trust-region radius. </td></tr>
<tr>
<td>tr_rad_min</td><td>OT_DOUBLE</td><td>Minimum trust-region radius. </td></tr>
<tr>
<td>tr_scale_vector</td><td>OT_DOUBLEVECTOR</td><td>Vector that tells where trust-region is applied. </td></tr>
<tr>
<td>tr_tol</td><td>OT_DOUBLE</td><td>Trust-region tolerance. Below this value another scalar is equal to the trust region radius. </td></tr>
<tr>
<td>use_anderson</td><td>OT_BOOL</td><td>Use Anderson Acceleration. (default false) </td></tr>
<tr>
<td>watchdog</td><td>OT_INT</td><td>Number of watchdog iterations in feasibility iterations. After this amount of iterations, it is checked with the contraction acceptance value, if iterations are converging. </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>qrsqp <a class="anchor" id="plugin_Nlpsol_qrsqp"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>A textbook SQPMethod</p>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_22u">https://github.com/casadi/casadi/wiki/L_22u</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>beta</td><td>OT_DOUBLE</td><td>Line-search parameter, restoration factor of stepsize </td></tr>
<tr>
<td>c1</td><td>OT_DOUBLE</td><td>Armijo condition, coefficient of decrease in merit </td></tr>
<tr>
<td>hessian_approximation</td><td>OT_STRING</td><td>limited-memory|exact </td></tr>
<tr>
<td>lbfgs_memory</td><td>OT_INT</td><td>Size of L-BFGS memory. </td></tr>
<tr>
<td>max_iter</td><td>OT_INT</td><td>Maximum number of SQP iterations </td></tr>
<tr>
<td>max_iter_ls</td><td>OT_INT</td><td>Maximum number of linesearch iterations </td></tr>
<tr>
<td>merit_memory</td><td>OT_INT</td><td>Size of memory to store history of merit function values </td></tr>
<tr>
<td>min_iter</td><td>OT_INT</td><td>Minimum number of SQP iterations </td></tr>
<tr>
<td>min_step_size</td><td>OT_DOUBLE</td><td>The size (inf-norm) of the step size should not become smaller than this. </td></tr>
<tr>
<td>print_header</td><td>OT_BOOL</td><td>Print the header with problem statistics </td></tr>
<tr>
<td>print_iteration</td><td>OT_BOOL</td><td>Print the iterations </td></tr>
<tr>
<td>qpsol</td><td>OT_STRING</td><td>The QP solver to be used by the SQP method [qrqp] </td></tr>
<tr>
<td>qpsol_options</td><td>OT_DICT</td><td>Options to be passed to the QP solver </td></tr>
<tr>
<td>regularize</td><td>OT_BOOL</td><td>Automatic regularization of Lagrange Hessian. </td></tr>
<tr>
<td>tol_du</td><td>OT_DOUBLE</td><td>Stopping criterion for dual infeasability </td></tr>
<tr>
<td>tol_pr</td><td>OT_DOUBLE</td><td>Stopping criterion for primal infeasibility </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>scpgen <a class="anchor" id="plugin_Nlpsol_scpgen"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>A structure-exploiting sequential quadratic programming (to be come sequential convex programming) method for nonlinear programming.</p>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_232">https://github.com/casadi/casadi/wiki/L_232</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>beta</td><td>OT_DOUBLE</td><td>Line-search parameter, restoration factor of stepsize </td></tr>
<tr>
<td>c1</td><td>OT_DOUBLE</td><td>Armijo condition, coefficient of decrease in merit </td></tr>
<tr>
<td>codegen</td><td>OT_BOOL</td><td>C-code generation </td></tr>
<tr>
<td>hessian_approximation</td><td>OT_STRING</td><td>gauss-newton|exact </td></tr>
<tr>
<td>lbfgs_memory</td><td>OT_INT</td><td>Size of L-BFGS memory. </td></tr>
<tr>
<td>max_iter</td><td>OT_INT</td><td>Maximum number of SQP iterations </td></tr>
<tr>
<td>max_iter_ls</td><td>OT_INT</td><td>Maximum number of linesearch iterations </td></tr>
<tr>
<td>merit_memsize</td><td>OT_INT</td><td>Size of memory to store history of merit function values </td></tr>
<tr>
<td>merit_start</td><td>OT_DOUBLE</td><td>Lower bound for the merit function parameter </td></tr>
<tr>
<td>name_x</td><td>OT_STRINGVECTOR</td><td>Names of the variables. </td></tr>
<tr>
<td>print_header</td><td>OT_BOOL</td><td>Print the header with problem statistics </td></tr>
<tr>
<td>print_x</td><td>OT_INTVECTOR</td><td>Which variables to print. </td></tr>
<tr>
<td>qpsol</td><td>OT_STRING</td><td>The QP solver to be used by the SQP method </td></tr>
<tr>
<td>qpsol_options</td><td>OT_DICT</td><td>Options to be passed to the QP solver </td></tr>
<tr>
<td>reg_threshold</td><td>OT_DOUBLE</td><td>Threshold for the regularization. </td></tr>
<tr>
<td>regularize</td><td>OT_BOOL</td><td>Automatic regularization of Lagrange Hessian. </td></tr>
<tr>
<td>tol_du</td><td>OT_DOUBLE</td><td>Stopping criterion for dual infeasability </td></tr>
<tr>
<td>tol_pr</td><td>OT_DOUBLE</td><td>Stopping criterion for primal infeasibility </td></tr>
<tr>
<td>tol_pr_step</td><td>OT_DOUBLE</td><td>Stopping criterion for the step size </td></tr>
<tr>
<td>tol_reg</td><td>OT_DOUBLE</td><td>Stopping criterion for regularization </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>sqpmethod <a class="anchor" id="plugin_Nlpsol_sqpmethod"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>A textbook SQPMethod</p>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_22x">https://github.com/casadi/casadi/wiki/L_22x</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>beta</td><td>OT_DOUBLE</td><td>Line-search parameter, restoration factor of stepsize </td></tr>
<tr>
<td>c1</td><td>OT_DOUBLE</td><td>Armijo condition, coefficient of decrease in merit </td></tr>
<tr>
<td>convexify_margin</td><td>OT_DOUBLE</td><td>When using a convexification strategy, make sure that the smallest eigenvalue is at least this (default: 1e-7). </td></tr>
<tr>
<td>convexify_strategy</td><td>OT_STRING</td><td>NONE|regularize|eigen-reflect|eigen-clip. Strategy to convexify the Lagrange Hessian before passing it to the solver. </td></tr>
<tr>
<td>elastic_mode</td><td>OT_BOOL</td><td>Enable the elastic mode which is used when the QP is infeasible (default: false). </td></tr>
<tr>
<td>gamma_0</td><td>OT_DOUBLE</td><td>Starting value for the penalty parameter of elastic mode (default: 1). </td></tr>
<tr>
<td>gamma_1_min</td><td>OT_DOUBLE</td><td>Minimum value for gamma_1 (default: 1e-5). </td></tr>
<tr>
<td>gamma_max</td><td>OT_DOUBLE</td><td>Maximum value for the penalty parameter of elastic mode (default: 1e20). </td></tr>
<tr>
<td>hess_lag</td><td>OT_FUNCTION</td><td>Function for calculating the Hessian of the Lagrangian (autogenerated by default) </td></tr>
<tr>
<td>hessian_approximation</td><td>OT_STRING</td><td>limited-memory|exact </td></tr>
<tr>
<td>init_feasible</td><td>OT_BOOL</td><td>Initialize the QP subproblems with a feasible initial value (default: false). </td></tr>
<tr>
<td>jac_fg</td><td>OT_FUNCTION</td><td>Function for calculating the gradient of the objective and Jacobian of the constraints (autogenerated by default) </td></tr>
<tr>
<td>lbfgs_memory</td><td>OT_INT</td><td>Size of L-BFGS memory. </td></tr>
<tr>
<td>max_iter</td><td>OT_INT</td><td>Maximum number of SQP iterations </td></tr>
<tr>
<td>max_iter_eig</td><td>OT_DOUBLE</td><td>Maximum number of iterations to compute an eigenvalue decomposition (default: 50). </td></tr>
<tr>
<td>max_iter_ls</td><td>OT_INT</td><td>Maximum number of linesearch iterations </td></tr>
<tr>
<td>merit_memory</td><td>OT_INT</td><td>Size of memory to store history of merit function values </td></tr>
<tr>
<td>min_iter</td><td>OT_INT</td><td>Minimum number of SQP iterations </td></tr>
<tr>
<td>min_step_size</td><td>OT_DOUBLE</td><td>The size (inf-norm) of the step size should not become smaller than this. </td></tr>
<tr>
<td>print_header</td><td>OT_BOOL</td><td>Print the header with problem statistics </td></tr>
<tr>
<td>print_iteration</td><td>OT_BOOL</td><td>Print the iterations </td></tr>
<tr>
<td>print_status</td><td>OT_BOOL</td><td>Print a status message after solving </td></tr>
<tr>
<td>qpsol</td><td>OT_STRING</td><td>The QP solver to be used by the SQP method [qpoases] </td></tr>
<tr>
<td>qpsol_options</td><td>OT_DICT</td><td>Options to be passed to the QP solver </td></tr>
<tr>
<td>second_order_corrections</td><td>OT_BOOL</td><td>Enable second order corrections. These are used when a step is considered bad by the merit function and constraint norm (default: false). </td></tr>
<tr>
<td>tol_du</td><td>OT_DOUBLE</td><td>Stopping criterion for dual infeasability </td></tr>
<tr>
<td>tol_pr</td><td>OT_DOUBLE</td><td>Stopping criterion for primal infeasibility </td></tr>
</table>
</dd></dl>
</div><!-- contents -->
</body>
</html>
