<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>CasADi: Title</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<link rel="search" href="../../search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="CasADi"/>
<link href="../../customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://casadi.org"><img src="/api/html/casadi.png" alt="CasADi" height="55px"/></a>&#160;<span>internal API<sup style="font-size:30%">(<a href="../../../html/index.html">switch to public</a>)</sup></span> - <a href="https://github.com/casadi/casadi/tree/896ebb1083311cfdb392f411ba83385080a05ed3" id="896ebb1083311cfdb392f411ba83385080a05ed3" >revision 3.6.2</a></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Title</div>  </div>
</div><!--header-->
<div class="contents">
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Create a QP solver Solves the following strictly convex problem:</p>
<pre class="fragment">min          1/2 x' H x + g' x
x

subject to
LBA &lt;= A x &lt;= UBA
LBX &lt;= x   &lt;= UBX

resize(Q x, np, np) + P &gt;= 0 (psd)

with :
H sparse (n x n) positive definite
g dense  (n x 1)
A sparse (nc x n)
Q sparse symmetric (np^2 x n)
P sparse symmetric (np x nq)

n: number of decision variables (x)
nc: number of constraints (A)
nq: shape of psd constraint matrix</pre><p>If H is not positive-definite, the solver should throw an error.</p>
<p>Second-order cone constraints can be added as psd constraints through a helper function 'soc':</p>
<p>x in R^n y in R</p>
<p>|| x ||_2 &lt;= y</p>
<p>&lt;=&gt;</p>
<p>soc(x, y) psd</p>
<p>This can be proven with soc(x, y)=[y*I x; x' y] using the Shur complement.</p>
<h3><a class="anchor" id="autotoc_md0"></a>
General information</h3>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description</th><th>Used in </th></tr>
<tr>
<td>ad_weight</td><td>OT_DOUBLE</td><td>Weighting factor for derivative calculation.When there is an option of either using forward or reverse mode directional derivatives, the condition ad_weight*nf&lt;=(1-ad_weight)*na is used where nf and na are estimates of the number of forward/reverse mode directional derivatives needed. By default, ad_weight is calculated automatically, but this can be overridden by setting this option. In particular, 0 means forcing forward mode and 1 forcing reverse mode. Leave unset for (class specific) heuristics.</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>ad_weight_sp</td><td>OT_DOUBLE</td><td>Weighting factor for sparsity pattern calculation calculation.Overrides default behavior. Set to 0 and 1 to force forward and reverse mode respectively. Cf. option "ad_weight". When set to -1, sparsity is completely ignored and dense matrices are used.</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>always_inline</td><td>OT_BOOL</td><td>Force inlining.</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>cache</td><td>OT_DICT</td><td>Prepopulate the function cache. Default: empty</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>compiler</td><td>OT_STRING</td><td>Just-in-time compiler plugin to be used.</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>custom_jacobian</td><td>OT_FUNCTION</td><td>Override CasADi's AD. Use together with 'jac_penalty': 0. Note: Highly experimental. Syntax may break often.</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>der_options</td><td>OT_DICT</td><td>Default options to be used to populate forward_options, reverse_options, and jacobian_options before those options are merged in.</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>derivative_of</td><td>OT_FUNCTION</td><td>The function is a derivative of another function. The type of derivative (directional derivative, Jacobian) is inferred from the function name.</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>discrete</td><td>OT_BOOLVECTOR</td><td>Indicates which of the variables are discrete, i.e. integer-valued</td><td><a class="el" href="../../df/de0/classcasadi_1_1Conic.html" title="Internal class.">casadi::Conic</a> </td></tr>
<tr>
<td>dump</td><td>OT_BOOL</td><td>Dump function to file upon first evaluation. [false]</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>dump_dir</td><td>OT_STRING</td><td>Directory to dump inputs/outputs to. Make sure the directory exists [.]</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>dump_format</td><td>OT_STRING</td><td>Choose file format to dump matrices. See <a class="el" href="../../da/d45/classcasadi_1_1Matrix.html#ab2064decec05ac73098d1b2b20a1c77e">DM.from_file</a> [mtx]</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>dump_in</td><td>OT_BOOL</td><td>Dump numerical values of inputs to file (readable with <a class="el" href="../../da/d45/classcasadi_1_1Matrix.html#ab2064decec05ac73098d1b2b20a1c77e">DM.from_file</a>) [default: false]</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>dump_out</td><td>OT_BOOL</td><td>Dump numerical values of outputs to file (readable with <a class="el" href="../../da/d45/classcasadi_1_1Matrix.html#ab2064decec05ac73098d1b2b20a1c77e">DM.from_file</a>) [default: false]</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>enable_fd</td><td>OT_BOOL</td><td>Enable derivative calculation by finite differencing. [default: false]]</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>enable_forward</td><td>OT_BOOL</td><td>Enable derivative calculation using generated functions for Jacobian-times-vector products - typically using forward mode AD - if available. [default: true]</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>enable_jacobian</td><td>OT_BOOL</td><td>Enable derivative calculation using generated functions for Jacobians of all differentiable outputs with respect to all differentiable inputs - if available. [default: true]</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>enable_reverse</td><td>OT_BOOL</td><td>Enable derivative calculation using generated functions for transposed Jacobian-times-vector products - typically using reverse mode AD - if available. [default: true]</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>error_on_fail</td><td>OT_BOOL</td><td>Throw exceptions when function evaluation fails (default true).</td><td><a class="el" href="../../db/da0/classcasadi_1_1ProtoFunction.html" title="Base class for FunctionInternal and LinsolInternal.">casadi::ProtoFunction</a> </td></tr>
<tr>
<td>fd_method</td><td>OT_STRING</td><td>Method for finite differencing [default 'central']</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>fd_options</td><td>OT_DICT</td><td><a class="el" href="../../db/d35/structcasadi_1_1Options.html" title="Options metadata for a class.">Options</a> to be passed to the finite difference instance</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>forward_options</td><td>OT_DICT</td><td><a class="el" href="../../db/d35/structcasadi_1_1Options.html" title="Options metadata for a class.">Options</a> to be passed to a forward mode constructor</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>gather_stats</td><td>OT_BOOL</td><td>Deprecated option (ignored): Statistics are now always collected.</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>input_scheme</td><td>OT_STRINGVECTOR</td><td>Deprecated option (ignored)</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>inputs_check</td><td>OT_BOOL</td><td>Throw exceptions when the numerical values of the inputs don't make sense</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>is_diff_in</td><td>OT_BOOLVECTOR</td><td>Indicate for each input if it should be differentiable.</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>is_diff_out</td><td>OT_BOOLVECTOR</td><td>Indicate for each output if it should be differentiable.</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>jac_penalty</td><td>OT_DOUBLE</td><td>When requested for a number of forward/reverse directions, it may be cheaper to compute first the full jacobian and then multiply with seeds, rather than obtain the requested directions in a straightforward manner. Casadi uses a heuristic to decide which is cheaper. A high value of 'jac_penalty' makes it less likely for the heurstic to chose the full Jacobian strategy. The special value -1 indicates never to use the full Jacobian strategy</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>jacobian_options</td><td>OT_DICT</td><td><a class="el" href="../../db/d35/structcasadi_1_1Options.html" title="Options metadata for a class.">Options</a> to be passed to a Jacobian constructor</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>jit</td><td>OT_BOOL</td><td>Use just-in-time compiler to speed up the evaluation</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>jit_cleanup</td><td>OT_BOOL</td><td>Cleanup up the temporary source file that jit creates. Default: true</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>jit_name</td><td>OT_STRING</td><td>The file name used to write out code. The actual file names used depend on 'jit_temp_suffix' and include extensions. Default: 'jit_tmp'</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>jit_options</td><td>OT_DICT</td><td><a class="el" href="../../db/d35/structcasadi_1_1Options.html" title="Options metadata for a class.">Options</a> to be passed to the jit compiler.</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>jit_serialize</td><td>OT_STRING</td><td>Specify behaviour when serializing a jitted function: SOURCE|link|embed.</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>jit_temp_suffix</td><td>OT_BOOL</td><td>Use a temporary (seemingly random) filename suffix for generated code and libraries. This is desired for thread-safety. This behaviour may defeat caching compiler wrappers. Default: true</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>max_io</td><td>OT_INT</td><td>Acceptable number of inputs and outputs. Warn if exceeded.</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>max_num_dir</td><td>OT_INT</td><td>Specify the maximum number of directions for derivative functions. Overrules the builtin optimized_num_dir.</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>never_inline</td><td>OT_BOOL</td><td>Forbid inlining.</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>output_scheme</td><td>OT_STRINGVECTOR</td><td>Deprecated option (ignored)</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>post_expand</td><td>OT_BOOL</td><td>After construction, expand this <a class="el" href="../../da/da4/classcasadi_1_1Function.html" title="Function object.">Function</a>. Default: False</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>post_expand_options</td><td>OT_DICT</td><td><a class="el" href="../../db/d35/structcasadi_1_1Options.html" title="Options metadata for a class.">Options</a> to be passed to post-construction expansion. Default: empty</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>print_in</td><td>OT_BOOL</td><td>Print numerical values of inputs [default: false]</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>print_out</td><td>OT_BOOL</td><td>Print numerical values of outputs [default: false]</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>print_problem</td><td>OT_BOOL</td><td>Print a numeric description of the problem</td><td><a class="el" href="../../df/de0/classcasadi_1_1Conic.html" title="Internal class.">casadi::Conic</a> </td></tr>
<tr>
<td>print_time</td><td>OT_BOOL</td><td>print information about execution time. Implies record_time.</td><td><a class="el" href="../../db/da0/classcasadi_1_1ProtoFunction.html" title="Base class for FunctionInternal and LinsolInternal.">casadi::ProtoFunction</a> </td></tr>
<tr>
<td>record_time</td><td>OT_BOOL</td><td>record information about execution time, for retrieval with stats().</td><td><a class="el" href="../../db/da0/classcasadi_1_1ProtoFunction.html" title="Base class for FunctionInternal and LinsolInternal.">casadi::ProtoFunction</a> </td></tr>
<tr>
<td>regularity_check</td><td>OT_BOOL</td><td>Throw exceptions when NaN or Inf appears during evaluation</td><td><a class="el" href="../../db/da0/classcasadi_1_1ProtoFunction.html" title="Base class for FunctionInternal and LinsolInternal.">casadi::ProtoFunction</a> </td></tr>
<tr>
<td>reverse_options</td><td>OT_DICT</td><td><a class="el" href="../../db/d35/structcasadi_1_1Options.html" title="Options metadata for a class.">Options</a> to be passed to a reverse mode constructor</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>user_data</td><td>OT_VOIDPTR</td><td>A user-defined field that can be used to identify the function or pass additional information</td><td><a class="el" href="../../d2/dab/classcasadi_1_1FunctionInternal.html" title="Internal class for Function.">casadi::FunctionInternal</a> </td></tr>
<tr>
<td>verbose</td><td>OT_BOOL</td><td>Verbose evaluation &ndash; for debugging</td><td><a class="el" href="../../db/da0/classcasadi_1_1ProtoFunction.html" title="Base class for FunctionInternal and LinsolInternal.">casadi::ProtoFunction</a> </td></tr>
</table>
</dd></dl>
<p><a class="anchor" id="schemes"></a></p><table class="doxtable">
<caption><a class="el" href="../../d1/d44/classcasadi_1_1Input.html" title="Input instruction.">Input</a> scheme: <a class="el" href="../../d7/d23/namespacecasadi.html#a34bce76c4159a28fab7b3240c17791f8" title="Input arguments of a QP problem.">casadi::ConicInput</a> (CONIC_NUM_IN = 12)</caption>
<tr>
<th>Full name</th><th>Short</th><th>Description </th></tr>
<tr>
<td>CONIC_H</td><td>h</td><td>The square matrix H: sparse, (n x n). Only the lower triangular part is actually used. The matrix is assumed to be symmetrical. </td></tr>
<tr>
<td>CONIC_G</td><td>g</td><td>The vector g: dense, (n x 1) </td></tr>
<tr>
<td>CONIC_A</td><td>a</td><td>The matrix A: sparse, (nc x n) - product with x must be dense. </td></tr>
<tr>
<td>CONIC_LBA</td><td>lba</td><td>dense, (nc x 1) </td></tr>
<tr>
<td>CONIC_UBA</td><td>uba</td><td>dense, (nc x 1) </td></tr>
<tr>
<td>CONIC_LBX</td><td>lbx</td><td>dense, (n x 1) </td></tr>
<tr>
<td>CONIC_UBX</td><td>ubx</td><td>dense, (n x 1) </td></tr>
<tr>
<td>CONIC_X0</td><td>x0</td><td>dense, (n x 1) </td></tr>
<tr>
<td>CONIC_LAM_X0</td><td>lam_x0</td><td>dense </td></tr>
<tr>
<td>CONIC_LAM_A0</td><td>lam_a0</td><td>dense </td></tr>
<tr>
<td>CONIC_Q</td><td>q</td><td>The matrix Q: sparse symmetric, (np^2 x n) </td></tr>
<tr>
<td>CONIC_P</td><td>p</td><td>The matrix P: sparse symmetric, (np x np) </td></tr>
</table>
<p><a class="anchor" id="schemes"></a></p><table class="doxtable">
<caption><a class="el" href="../../df/da2/classcasadi_1_1Output.html" title="Input instruction.">Output</a> scheme: <a class="el" href="../../d7/d23/namespacecasadi.html#affec1f380df22cc4934c68b5487b7396" title="Output arguments of an QP Solver.">casadi::ConicOutput</a> (CONIC_NUM_OUT = 4)</caption>
<tr>
<th>Full name</th><th>Short</th><th>Description </th></tr>
<tr>
<td>CONIC_X</td><td>x</td><td>The primal solution. </td></tr>
<tr>
<td>CONIC_COST</td><td>cost</td><td>The optimal cost. </td></tr>
<tr>
<td>CONIC_LAM_A</td><td>lam_a</td><td>The dual solution corresponding to linear bounds. </td></tr>
<tr>
<td>CONIC_LAM_X</td><td>lam_x</td><td>The dual solution corresponding to simple bounds. </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md1"></a>
List of plugins</h3>
<p>- <a href='#plugin_Conic_cbc'>cbc</a> </p>
<p>- <a href='#plugin_Conic_clp'>clp</a> </p>
<p>- <a href='#plugin_Conic_cplex'>cplex</a> </p>
<p>- <a href='#plugin_Conic_gurobi'>gurobi</a> </p>
<p>- <a href='#plugin_Conic_highs'>highs</a> </p>
<p>- <a href='#plugin_Conic_hpipm'>hpipm</a> </p>
<p>- <a href='#plugin_Conic_hpmpc'>hpmpc</a> </p>
<p>- <a href='#plugin_Conic_ooqp'>ooqp</a> </p>
<p>- <a href='#plugin_Conic_osqp'>osqp</a> </p>
<p>- <a href='#plugin_Conic_proxqp'>proxqp</a> </p>
<p>- <a href='#plugin_Conic_qpoases'>qpoases</a> </p>
<p>- <a href='#plugin_Conic_sqic'>sqic</a> </p>
<p>- <a href='#plugin_Conic_superscs'>superscs</a> </p>
<p>- <a href='#plugin_Conic_ipqp'>ipqp</a> </p>
<p>- <a href='#plugin_Conic_nlpsol'>nlpsol</a> </p>
<p>- <a href='#plugin_Conic_qrqp'>qrqp</a> </p>
<p>Note: some of the plugins in this list might not be available on your system.  Also, there might be extra plugins available to you that are not listed here. You can obtain their documentation with <code>Conic.doc("myextraplugin")</code></p>
<hr  />
  <h4>cbc <a class="anchor" id="plugin_Conic_cbc"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Interface to Cbc solver for sparse Quadratic Programs</p>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_221">https://github.com/casadi/casadi/wiki/L_221</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>cbc</td><td>OT_DICT</td><td><a class="el" href="../../db/d35/structcasadi_1_1Options.html" title="Options metadata for a class.">Options</a> to be passed to CBC.Three sets of options are supported. The first can be found in OsiSolverParameters.hpp. The second can be found in CbcModel.hpp. The third are options that can be passed to CbcMain1. </td></tr>
<tr>
<td>hot_start</td><td>OT_BOOL</td><td>Hot start with x0 [Default false]. </td></tr>
<tr>
<td>sos_groups</td><td>OT_INTVECTORVECTOR</td><td>Definition of SOS groups by indices. </td></tr>
<tr>
<td>sos_types</td><td>OT_INTVECTOR</td><td>Specify 1 or 2 for each SOS group. </td></tr>
<tr>
<td>sos_weights</td><td>OT_DOUBLEVECTORVECTOR</td><td>Weights corresponding to SOS entries. </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>clp <a class="anchor" id="plugin_Conic_clp"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Interface to Clp solver for sparse Quadratic Programs</p>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_22d">https://github.com/casadi/casadi/wiki/L_22d</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>clp</td><td>OT_DICT</td><td><a class="el" href="../../db/d35/structcasadi_1_1Options.html" title="Options metadata for a class.">Options</a> to be passed to CLP. A first set of options can be found in ClpParameters.hpp. eg. 'PrimalTolerance'. There are other options in additions. 'AutomaticScaling' (bool) is recognised. 'initial_solve' (default off) activates the use of Clp's initialSolve. 'initial_solve_options' takes a dictionary with following keys (see ClpSolve.hpp): SolveType (string), PresolveType (string), NumberPasses, SpecialOptions (intvectorvector), IndependentOptions (intvectorvector). </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>cplex <a class="anchor" id="plugin_Conic_cplex"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Interface to Cplex solver for sparse Quadratic Programs</p>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_22a">https://github.com/casadi/casadi/wiki/L_22a</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>cplex</td><td>OT_DICT</td><td><a class="el" href="../../db/d35/structcasadi_1_1Options.html" title="Options metadata for a class.">Options</a> to be passed to CPLEX </td></tr>
<tr>
<td>dep_check</td><td>OT_INT</td><td>Detect redundant constraints. </td></tr>
<tr>
<td>dump_filename</td><td>OT_STRING</td><td>The filename to dump to. </td></tr>
<tr>
<td>dump_to_file</td><td>OT_BOOL</td><td>Dumps QP to file in CPLEX format. </td></tr>
<tr>
<td>mip_start</td><td>OT_BOOL</td><td>Hot start integers with x0 [Default false]. </td></tr>
<tr>
<td>qp_method</td><td>OT_INT</td><td>Determines which CPLEX algorithm to use. </td></tr>
<tr>
<td>sos_groups</td><td>OT_INTVECTORVECTOR</td><td>Definition of SOS groups by indices. </td></tr>
<tr>
<td>sos_types</td><td>OT_INTVECTOR</td><td>Specify 1 or 2 for each SOS group. </td></tr>
<tr>
<td>sos_weights</td><td>OT_DOUBLEVECTORVECTOR</td><td>Weights corresponding to SOS entries. </td></tr>
<tr>
<td>tol</td><td>OT_DOUBLE</td><td>Tolerance of solver </td></tr>
<tr>
<td>version_suffix</td><td>OT_STRING</td><td>Specify version of cplex to load. We will attempt to load libcplex&lt;version_suffix&gt;.[so|dll|dylib]. Default value is taken from CPLEX_VERSION env variable. </td></tr>
<tr>
<td>warm_start</td><td>OT_BOOL</td><td>Use warm start with simplex methods (affects only the simplex methods). </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>gurobi <a class="anchor" id="plugin_Conic_gurobi"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Interface to the GUROBI Solver for quadratic programming</p>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_22q">https://github.com/casadi/casadi/wiki/L_22q</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>gurobi</td><td>OT_DICT</td><td><a class="el" href="../../db/d35/structcasadi_1_1Options.html" title="Options metadata for a class.">Options</a> to be passed to gurobi. </td></tr>
<tr>
<td>sos_groups</td><td>OT_INTVECTORVECTOR</td><td>Definition of SOS groups by indices. </td></tr>
<tr>
<td>sos_types</td><td>OT_INTVECTOR</td><td>Specify 1 or 2 for each SOS group. </td></tr>
<tr>
<td>sos_weights</td><td>OT_DOUBLEVECTORVECTOR</td><td>Weights corresponding to SOS entries. </td></tr>
<tr>
<td>vtype</td><td>OT_STRINGVECTOR</td><td>Type of variables: [CONTINUOUS|binary|integer|semicont|semiint] </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>highs <a class="anchor" id="plugin_Conic_highs"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Interface to HiGHS solver for sparse Quadratic Programs, see highs.dev for more information and <a href="https://www.maths.ed.ac.uk/hall/HiGHS/HighsOptions.html">https://www.maths.ed.ac.uk/hall/HiGHS/HighsOptions.html</a> for a list of options.</p>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_22f">https://github.com/casadi/casadi/wiki/L_22f</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>highs</td><td>OT_DICT</td><td><a class="el" href="../../db/d35/structcasadi_1_1Options.html" title="Options metadata for a class.">Options</a> to be passed to HiGHS. </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>hpipm <a class="anchor" id="plugin_Conic_hpipm"></a> </h4>
<dl class="section user"><dt></dt><dd>Interface to HMPC Solver</dd></dl>
<p>In order to use this interface, you must:</p>
<ul>
<li>Decision variables must only by state and control, and the variable ordering must be [x0 u0 x1 u1 ...]</li>
<li><p class="startli">The constraints must be in order: [ gap0 lincon0 gap1 lincon1 ]</p>
<p class="startli">gap: Ak+1 = Ak xk + Bk uk lincon: yk= Ck xk + Dk uk</p>
</li>
</ul>
<pre class="fragment">       A0 B0 -I
       C0 D0
              A1 B1 -I
              C1 D1</pre><p>where I must be a diagonal sparse matrix</p><ul>
<li><p class="startli">Either supply all of N, nx, ng, nu options or rely on automatic detection</p>
<p class="startli">Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_242">https://github.com/casadi/casadi/wiki/L_242</a></p>
</li>
</ul>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>N</td><td>OT_INT</td><td>OCP horizon </td></tr>
<tr>
<td>hpipm</td><td>OT_DICT</td><td><a class="el" href="../../db/d35/structcasadi_1_1Options.html" title="Options metadata for a class.">Options</a> to be passed to hpipm </td></tr>
<tr>
<td>inf</td><td>OT_DOUBLE</td><td>Replace infinities by this amount [default: 1e8] </td></tr>
<tr>
<td>ng</td><td>OT_INTVECTOR</td><td>Number of non-dynamic constraints, length N+1 </td></tr>
<tr>
<td>nu</td><td>OT_INTVECTOR</td><td>Number of controls, length N </td></tr>
<tr>
<td>nx</td><td>OT_INTVECTOR</td><td>Number of states, length N+1 </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>hpmpc <a class="anchor" id="plugin_Conic_hpmpc"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Interface to HMPC Solver</p>
<p>In order to use this interface, you must:</p>
<ul>
<li>Decision variables must only by state and control, and the variable ordering must be [x0 u0 x1 u1 ...]</li>
<li><p class="startli">The constraints must be in order: [ gap0 lincon0 gap1 lincon1 ]</p>
<p class="startli">gap: Ak+1 = Ak xk + Bk uk lincon: yk= Ck xk + Dk uk</p>
</li>
</ul>
<pre class="fragment">       A0 B0 -I
       C0 D0
              A1 B1 -I
              C1 D1</pre><p>where I must be a diagonal sparse matrix</p><ul>
<li><p class="startli">Either supply all of N, nx, ng, nu options or rely on automatic detection</p>
<p class="startli">Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_22p">https://github.com/casadi/casadi/wiki/L_22p</a></p>
</li>
</ul>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>N</td><td>OT_INT</td><td>OCP horizon </td></tr>
<tr>
<td>blasfeo_target</td><td>OT_STRING</td><td>hpmpc target </td></tr>
<tr>
<td>inf</td><td>OT_DOUBLE</td><td>HPMPC cannot handle infinities. Infinities will be replaced by this option's value. </td></tr>
<tr>
<td>max_iter</td><td>OT_INT</td><td>Max number of iterations </td></tr>
<tr>
<td>mu0</td><td>OT_DOUBLE</td><td>Max element in cost function as estimate of max multiplier </td></tr>
<tr>
<td>ng</td><td>OT_INTVECTOR</td><td>Number of non-dynamic constraints, length N+1 </td></tr>
<tr>
<td>nu</td><td>OT_INTVECTOR</td><td>Number of controls, length N </td></tr>
<tr>
<td>nx</td><td>OT_INTVECTOR</td><td>Number of states, length N+1 </td></tr>
<tr>
<td>print_level</td><td>OT_INT</td><td>Amount of diagnostic printing [Default: 1]. </td></tr>
<tr>
<td>target</td><td>OT_STRING</td><td>hpmpc target </td></tr>
<tr>
<td>tol</td><td>OT_DOUBLE</td><td>Tolerance in the duality measure </td></tr>
<tr>
<td>warm_start</td><td>OT_BOOL</td><td>Use warm-starting </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>ooqp <a class="anchor" id="plugin_Conic_ooqp"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Interface to the OOQP Solver for quadratic programming The current implementation assumes that OOQP is configured with the MA27 sparse linear solver.</p>
<p>NOTE: when doing multiple calls to evaluate(), check if you need to reInit();</p>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_222">https://github.com/casadi/casadi/wiki/L_222</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>artol</td><td>OT_DOUBLE</td><td>tolerance as provided with setArTol to OOQP </td></tr>
<tr>
<td>mutol</td><td>OT_DOUBLE</td><td>tolerance as provided with setMuTol to OOQP </td></tr>
<tr>
<td>print_level</td><td>OT_INT</td><td>Print level. OOQP listens to print_level 0, 10 and 100 </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>osqp <a class="anchor" id="plugin_Conic_osqp"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Interface to the OSQP Solver for quadratic programming</p>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_220">https://github.com/casadi/casadi/wiki/L_220</a></p>
<dl class="section user"><dt></dt><dd>Interface to the PROXQP Solver for quadratic programming</dd></dl>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_243">https://github.com/casadi/casadi/wiki/L_243</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>osqp</td><td>OT_DICT</td><td>const <a class="el" href="../../db/d35/structcasadi_1_1Options.html" title="Options metadata for a class.">Options</a> to be passed to osqp. </td></tr>
<tr>
<td>warm_start_dual</td><td>OT_BOOL</td><td>Use lam_a0 and lam_x0 input to warmstart [Default: truw]. </td></tr>
<tr>
<td>warm_start_primal</td><td>OT_BOOL</td><td>Use x0 input to warmstart [Default: true]. </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>proxqp <a class="anchor" id="plugin_Conic_proxqp"></a> </h4>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>proxqp</td><td>OT_DICT</td><td>const proxqp options. </td></tr>
<tr>
<td>warm_start_dual</td><td>OT_BOOL</td><td>Use y and z input to warmstart [Default: true]. </td></tr>
<tr>
<td>warm_start_primal</td><td>OT_BOOL</td><td>Use x input to warmstart [Default: true]. </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>qpoases <a class="anchor" id="plugin_Conic_qpoases"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Interface to QPOases Solver for quadratic programming </p><pre class="fragment">Extra doc: https://github.com/casadi/casadi/wiki/L_22o 
</pre><p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>CPUtime</td><td>OT_DOUBLE</td><td>The maximum allowed CPU time in seconds for the whole initialisation (and the actually required one on output). Disabled if unset. </td></tr>
<tr>
<td>boundRelaxation</td><td>OT_DOUBLE</td><td>Initial relaxation of bounds to start homotopy and initial value for far bounds. </td></tr>
<tr>
<td>boundTolerance</td><td>OT_DOUBLE</td><td>If upper and lower bounds differ less than this tolerance, they are regarded equal, i.e. as equality constraint. </td></tr>
<tr>
<td>enableCholeskyRefactorisation</td><td>OT_INT</td><td>Specifies the frequency of a full re-factorisation of projected Hessian matrix: 0: turns them off, 1: uses them at each iteration etc. </td></tr>
<tr>
<td>enableDriftCorrection</td><td>OT_INT</td><td>Specifies the frequency of drift corrections: 0: turns them off. </td></tr>
<tr>
<td>enableEqualities</td><td>OT_BOOL</td><td>Specifies whether equalities should be treated as always active (True) or not (False) </td></tr>
<tr>
<td>enableFarBounds</td><td>OT_BOOL</td><td>Enables the use of far bounds. </td></tr>
<tr>
<td>enableFlippingBounds</td><td>OT_BOOL</td><td>Enables the use of flipping bounds. </td></tr>
<tr>
<td>enableFullLITests</td><td>OT_BOOL</td><td>Enables condition-hardened (but more expensive) LI test. </td></tr>
<tr>
<td>enableInertiaCorrection</td><td>OT_BOOL</td><td>Should working set be repaired when negative curvature is discovered during hotstart. </td></tr>
<tr>
<td>enableNZCTests</td><td>OT_BOOL</td><td>Enables nonzero curvature tests. </td></tr>
<tr>
<td>enableRamping</td><td>OT_BOOL</td><td>Enables ramping. </td></tr>
<tr>
<td>enableRegularisation</td><td>OT_BOOL</td><td>Enables automatic Hessian regularisation. </td></tr>
<tr>
<td>epsDen</td><td>OT_DOUBLE</td><td>Denominator tolerance for ratio tests. </td></tr>
<tr>
<td>epsFlipping</td><td>OT_DOUBLE</td><td>Tolerance of squared Cholesky diagonal factor which triggers flipping bound. </td></tr>
<tr>
<td>epsIterRef</td><td>OT_DOUBLE</td><td>Early termination tolerance for iterative refinement. </td></tr>
<tr>
<td>epsLITests</td><td>OT_DOUBLE</td><td>Tolerance for linear independence tests. </td></tr>
<tr>
<td>epsNZCTests</td><td>OT_DOUBLE</td><td>Tolerance for nonzero curvature tests. </td></tr>
<tr>
<td>epsNum</td><td>OT_DOUBLE</td><td>Numerator tolerance for ratio tests. </td></tr>
<tr>
<td>epsRegularisation</td><td>OT_DOUBLE</td><td>Scaling factor of identity matrix used for Hessian regularisation. </td></tr>
<tr>
<td>finalRamping</td><td>OT_DOUBLE</td><td>Final value for ramping strategy. </td></tr>
<tr>
<td>growFarBounds</td><td>OT_DOUBLE</td><td>Factor to grow far bounds. </td></tr>
<tr>
<td>hessian_type</td><td>OT_STRING</td><td>Type of Hessian - see qpOASES documentation [UNKNOWN|posdef|semidef|indef|zero|identity]] </td></tr>
<tr>
<td>initialFarBounds</td><td>OT_DOUBLE</td><td>Initial size for far bounds. </td></tr>
<tr>
<td>initialRamping</td><td>OT_DOUBLE</td><td>Start value for ramping strategy. </td></tr>
<tr>
<td>initialStatusBounds</td><td>OT_STRING</td><td>Initial status of bounds at first iteration. </td></tr>
<tr>
<td>linsol_plugin</td><td>OT_STRING</td><td>Linear solver plugin </td></tr>
<tr>
<td>maxDualJump</td><td>OT_DOUBLE</td><td>Maximum allowed jump in dual variables in linear independence tests. </td></tr>
<tr>
<td>maxPrimalJump</td><td>OT_DOUBLE</td><td>Maximum allowed jump in primal variables in nonzero curvature tests. </td></tr>
<tr>
<td>max_schur</td><td>OT_INT</td><td>Maximal number of Schur updates [75] </td></tr>
<tr>
<td>nWSR</td><td>OT_INT</td><td>The maximum number of working set recalculations to be performed during the initial homotopy. Default is 5(nx + nc) </td></tr>
<tr>
<td>numRefinementSteps</td><td>OT_INT</td><td>Maximum number of iterative refinement steps. </td></tr>
<tr>
<td>numRegularisationSteps</td><td>OT_INT</td><td>Maximum number of successive regularisation steps. </td></tr>
<tr>
<td>printLevel</td><td>OT_STRING</td><td>Defines the amount of text output during QP solution, see Section 5.7 </td></tr>
<tr>
<td>schur</td><td>OT_BOOL</td><td>Use Schur Complement Approach [false] </td></tr>
<tr>
<td>sparse</td><td>OT_BOOL</td><td>Formulate the QP using sparse matrices. [false] </td></tr>
<tr>
<td>terminationTolerance</td><td>OT_DOUBLE</td><td>Relative termination tolerance to stop homotopy. </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>sqic <a class="anchor" id="plugin_Conic_sqic"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Interface to the SQIC solver for quadratic programming</p>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_21s">https://github.com/casadi/casadi/wiki/L_21s</a></p>
<hr  />
  <h4>superscs <a class="anchor" id="plugin_Conic_superscs"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Interface to the SuperSCS solver for conic programming</p>
<p>Joris Gillis, 2019</p>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_21z">https://github.com/casadi/casadi/wiki/L_21z</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>superscs</td><td>OT_DICT</td><td><a class="el" href="../../db/d35/structcasadi_1_1Options.html" title="Options metadata for a class.">Options</a> to be passed to superscs. </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>ipqp <a class="anchor" id="plugin_Conic_ipqp"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Solves QPs using a Mehrotra predictor-corrector interior point method</p>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_23c">https://github.com/casadi/casadi/wiki/L_23c</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>constr_viol_tol</td><td>OT_DOUBLE</td><td>Constraint violation tolerance [1e-8]. </td></tr>
<tr>
<td>dual_inf_tol</td><td>OT_DOUBLE</td><td>Dual feasibility violation tolerance [1e-8] </td></tr>
<tr>
<td>linear_solver</td><td>OT_STRING</td><td>A custom linear solver creator function [default: ldl] </td></tr>
<tr>
<td>linear_solver_options</td><td>OT_DICT</td><td><a class="el" href="../../db/d35/structcasadi_1_1Options.html" title="Options metadata for a class.">Options</a> to be passed to the linear solver </td></tr>
<tr>
<td>max_iter</td><td>OT_INT</td><td>Maximum number of iterations [1000]. </td></tr>
<tr>
<td>min_lam</td><td>OT_DOUBLE</td><td>Smallest multiplier treated as inactive for the initial active set [0]. </td></tr>
<tr>
<td>print_header</td><td>OT_BOOL</td><td>Print header [true]. </td></tr>
<tr>
<td>print_info</td><td>OT_BOOL</td><td>Print info [true]. </td></tr>
<tr>
<td>print_iter</td><td>OT_BOOL</td><td>Print iterations [true]. </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>nlpsol <a class="anchor" id="plugin_Conic_nlpsol"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p><a class="el" href="../../dd/de8/classcasadi_1_1Solve.html" title="An MX atomic for linear solver solution: x = r * A^-1 or x = r * A^-T.">Solve</a> QPs using an <a class="el" href="../../d8/dc2/classcasadi_1_1Nlpsol.html" title="NLP solver storage class.">Nlpsol</a> Use the 'nlpsol' option to specify the NLP solver to use.</p>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_235">https://github.com/casadi/casadi/wiki/L_235</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>nlpsol</td><td>OT_STRING</td><td>Name of solver. </td></tr>
<tr>
<td>nlpsol_options</td><td>OT_DICT</td><td><a class="el" href="../../db/d35/structcasadi_1_1Options.html" title="Options metadata for a class.">Options</a> to be passed to solver. </td></tr>
</table>
</dd></dl>
<hr  />
  <h4>qrqp <a class="anchor" id="plugin_Conic_qrqp"></a> </h4>
<dl class="section user"><dt></dt><dd></dd></dl>
<p><a class="el" href="../../dd/de8/classcasadi_1_1Solve.html" title="An MX atomic for linear solver solution: x = r * A^-1 or x = r * A^-T.">Solve</a> QPs using an active-set method</p>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_22y">https://github.com/casadi/casadi/wiki/L_22y</a></p>
<p><br  />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption>List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>constr_viol_tol</td><td>OT_DOUBLE</td><td>Constraint violation tolerance [1e-8]. </td></tr>
<tr>
<td>dual_inf_tol</td><td>OT_DOUBLE</td><td>Dual feasibility violation tolerance [1e-8] </td></tr>
<tr>
<td>max_iter</td><td>OT_INT</td><td>Maximum number of iterations [1000]. </td></tr>
<tr>
<td>min_lam</td><td>OT_DOUBLE</td><td>Smallest multiplier treated as inactive for the initial active set [0]. </td></tr>
<tr>
<td>print_header</td><td>OT_BOOL</td><td>Print header [true]. </td></tr>
<tr>
<td>print_info</td><td>OT_BOOL</td><td>Print info [true]. </td></tr>
<tr>
<td>print_iter</td><td>OT_BOOL</td><td>Print iterations [true]. </td></tr>
<tr>
<td>print_lincomb</td><td>OT_BOOL</td><td>Print dependant linear combinations of constraints [false]. Printed numbers are 0-based indices into the vector of [simple bounds;linear bounds] </td></tr>
</table>
</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Joel Andersson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2011-2015</dd></dl>
<p>Extra doc: <a href="https://github.com/casadi/casadi/wiki/L_21n">https://github.com/casadi/casadi/wiki/L_21n</a> </p>
</div><!-- contents -->
</body>
</html>
